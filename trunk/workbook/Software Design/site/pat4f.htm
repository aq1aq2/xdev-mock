<html><head>	<title>Flyweight</title><link href="ff.css" rel="stylesheet" type="text/css"></head><body>
<h2>Flyweight</h2>
<h3> Intent</h3><p>Use sharing to support large numbers of fine-grained objects efficiently.</p>
<h3> Motivation</h3><p>Some applications could benefit from using objects throughout their
design, but a naive implementation would be prohibitively expensive.</p>
<p>For example, most document editor implementations have text formatting
and editing facilities that are modularized to some extent.
Object-oriented document editors typically use objects to represent
embedded elements like tables and figures.  However, they usually stop
short of using an object for each character in the document, even
though doing so would promote flexibility at the finest levels in the
application. Characters and embedded elements could then be treated
uniformly with respect to how they are drawn and formatted. The
application could be extended to support new character sets without
disturbing other functionality. The application's object structure
could mimic the document's physical structure.  The following diagram 
shows how a document editor can use objects to represent characters.</p><p align=CENTER><img src="Pictures/flywe055.gif"></p>
<p>The drawback of such a design is its cost. Even moderate-sized
documents may require hundreds of thousands of character objects,
which will consume lots of memory and may incur unacceptable run-time
overhead.  The Flyweight pattern describes how to share objects to
allow their use at fine granularities without prohibitive cost.</p>


<p>A <strong>flyweight</strong> is a shared object that can be used in
multiple contexts simultaneously. The flyweight acts as an independent
object in each context&#151;it's indistinguishable from an instance of
the object that's not shared. Flyweights cannot make assumptions about
the context in which they operate. The key concept here is the
distinction between <strong>intrinsic</strong> and <strong>extrinsic</strong>
state.  Intrinsic state is stored in the flyweight; it consists of
information that's independent of the flyweight's context, thereby
making it sharable.  Extrinsic state depends on and varies with the
flyweight's context and therefore can't be shared. Client objects are
responsible for passing extrinsic state to the flyweight when it needs
it.</p>
<p>Flyweights model concepts or entities that are normally too plentiful
to represent with objects. For example, a document editor can create a
flyweight for each letter of the alphabet. Each flyweight stores a
character code, but its coordinate position in the document and its
typographic style can be determined from the text layout algorithms
and formatting commands in effect wherever the character appears. The
character code is intrinsic state, while the other information is
extrinsic.</p>
<p>Logically there is an object for every occurrence of a given character in
the document:</p>
<p align=CENTER><img src="Pictures/flywe054.gif"></p>
<p>Physically, however, there is one shared flyweight object per
character, and it appears in different contexts in the document
structure. Each occurrence of a particular character object refers to
the same instance in the shared pool of flyweight objects:</p><p align=CENTER><img src="Pictures/flywe052.gif"></p>
<p>The class structure for these objects is shown next.  Glyph is the
abstract class for graphical objects, some of which may be flyweights.
Operations that may depend on extrinsic state have it passed to them
as a parameter.  For example, Draw and Intersects must know which
context the glyph is in before they can do their job.</p><p align=CENTER><img src="Pictures/flywe053.gif"></p>
<p>A flyweight representing the letter "a" only stores the
corresponding character code; it doesn't need to store its location or
font. Clients supply the context-dependent information that the
flyweight needs to draw itself. For example, a Row glyph knows where
its children should draw themselves so that they are tiled
horizontally.  Thus it can pass each child its location in the draw
request.</p>
<p>Because the number of different character objects is far less than the
number of characters in the document, the total number of objects is
substantially less than what a naive implementation would use.  A
document in which all characters appear in the same font and color
will allocate on the order of 100 character objects (roughly the size
of the ASCII character set) regardless of the document's length.  And
since most documents use no more than 10 different font-color
combinations, this number won't grow appreciably in practice.  An
object abstraction thus becomes practical for individual characters.</p>
<h3> Applicability</h3><p>The Flyweight pattern's effectiveness depends heavily on how and where
it's used. Apply the Flyweight pattern when <em>all</em> of the following
are true:</p><ul>
<li>An application uses a large number of objects.</li>

<li>Storage costs are high because of the sheer quantity of objects.</li>

<li>Most object state can be made extrinsic.</li>

<li>Many groups of objects may be replaced by relatively few shared
objects once extrinsic state is removed.</li>

<li>The application doesn't depend on object identity. Since flyweight
objects may be shared, identity tests will return true for conceptually
distinct objects.</li></ul>
<h3> Structure</h3> <p align=CENTER><img src="Pictures/flywe050.gif"></p>
<p>The following object diagram shows how flyweights are shared:</p><p align=CENTER><img src="Pictures/flywe051.gif"></p>
<h3> Participants</h3><ul>
<li><b>Flyweight</b>


<ul>
<li>declares an interface through which flyweights can
receive and act on extrinsic state.</li></ul>



<li><b>ConcreteFlyweight</b> (Character)</li>


<ul>
<li>implements the Flyweight interface and adds storage for
intrinsic state, if any.  A ConcreteFlyweight object must be sharable. Any
state it stores must be intrinsic; that is, it must be
independent of the ConcreteFlyweight object's context.</li></ul>



<li><b>UnsharedConcreteFlyweight</b> (Row, Column)</li>


<ul>
<li>not all Flyweight subclasses need to be shared.  The
Flyweight interface <em>enables</em> sharing; it doesn't enforce it.
It's common for UnsharedConcreteFlyweight objects to have
ConcreteFlyweight objects as children at
some level in the flyweight object structure
(as the Row and Column classes have).</li></ul>



<li><b>FlyweightFactory</b></li>


<ul>
<li>creates and manages flyweight objects.</li>
<p><!-- extra space --></p>
<li>ensures that flyweights are shared properly.
When a client requests a flyweight, the FlyweightFactory object supplies
an existing instance or creates one, if none exists.</ul>



<li><b>Client</b></li>


<ul>
<li>maintains a reference to flyweight(s).</li>
<p><!-- extra space --></p>
<li>computes or stores the extrinsic state of flyweight(s).</li></ul></ul>
<h3> Collaborations</h3><ul>
<li>State that a flyweight needs to function must be characterized as
either intrinsic or extrinsic. Intrinsic state is stored in the
ConcreteFlyweight object; extrinsic state is stored or computed by
Client objects. Clients pass this state to the flyweight when
they invoke its operations.</li>

<li>Clients should not instantiate ConcreteFlyweights directly. Clients
must obtain ConcreteFlyweight objects exclusively from the
FlyweightFactory object to ensure they are shared properly.</li></ul>
<h3> Consequences</h3><p>Flyweights may introduce run-time costs associated with transferring,
finding, and/or computing extrinsic state, especially if it was
formerly stored as intrinsic state. However, such costs are offset by
space savings, which increase as more flyweights are shared.</p>
<p>Storage savings are a function of several factors:</p><ul>
<li>the reduction in the total number of instances that comes from
sharing</li>

<li>the amount of intrinsic state per object</li>

<li>whether extrinsic state is computed or stored.</li></ul>

<p>The more flyweights are shared, the greater the storage savings.  The
savings increase with the amount of shared state.  The greatest
savings occur when the objects use substantial quantities of both
intrinsic and extrinsic state, and the extrinsic state can be computed
rather than stored.  Then you save on storage in two ways: Sharing
reduces the cost of intrinsic state, and you trade extrinsic state for
computation time.</p>
<p>The Flyweight pattern is often combined with the
Composite  pattern to represent a hierarchical
structure as a graph with shared leaf nodes.  A consequence of sharing
is that flyweight leaf nodes cannot store a pointer to their parent.
Rather, the parent pointer is passed to the flyweight as part of its
extrinsic state.  This has a major impact on how the objects in the
hierarchy communicate with each other.</p>
<h3> Implementation</h3><p>Consider the following issues when implementing the Flyweight pattern:</p><ol>
<li><em>Removing extrinsic state.</em>
The pattern's applicability is determined largely by how easy it is to
identify extrinsic state and remove it from shared objects.  Removing
extrinsic state won't help reduce storage costs if there are as many
different kinds of extrinsic state as there are objects before
sharing. Ideally, extrinsic state can be computed from a separate
object structure, one with far smaller storage requirements.
<p>In our document editor, for example, we can store a map of typographic
information in a separate structure rather than store the font and
type style with each character object. The map keeps track of runs of
characters with the same typographic attributes. When a character
draws itself, it receives its typographic attributes as a side-effect
of the draw traversal. Because documents normally use just a few
different fonts and styles, storing this information externally to
each character object is far more efficient than storing it
internally.</p></li>
<li><em>Managing shared objects.</em>
Because objects are shared, clients shouldn't instantiate them
directly.  FlyweightFactory lets clients locate a particular
flyweight.  FlyweightFactory objects often use an associative store to
let clients look up flyweights of interest. For example, the
flyweight factory in the document editor example can keep a table of
flyweights indexed by character codes. The manager returns the proper
flyweight given its code, creating the flyweight if it does not
already exist.
<p>Sharability also implies some form of reference counting or garbage
collection to reclaim a flyweight's storage when it's no longer
needed.  However, neither is necessary if the number of flyweights is
fixed and small (e.g., flyweights for the ASCII character set).  In
that case, the flyweights are worth keeping around permanently.</p></li></ol><a name="samplecode"><a>
<h3> Sample Code</h3><p>Returning to our document formatter example, we can define a
<tt>Glyph</tt> base class for flyweight graphical objects.
Logically, glyphs are Composites (see Composite ) that have graphical attributes and can
draw themselves.  Here we focus on just the font attribute, but
the same approach can be used for any other graphical attributes
a glyph might have.</p>
<pre>
class Glyph {
public:
    virtual ~Glyph();

    virtual void Draw(Window*, GlyphContext&amp;);

    virtual void SetFont(Font*, GlyphContext&amp;);
    virtual Font* GetFont(GlyphContext&amp;);

    virtual void First(GlyphContext&amp;);
    virtual void Next(GlyphContext&amp;);
    virtual bool IsDone(GlyphContext&amp;);
    virtual Glyph* Current(GlyphContext&amp;);

    virtual void Insert(Glyph*, GlyphContext&amp;);
    virtual void Remove(GlyphContext&amp;);
protected:
    Glyph();
};
</pre>
<p>The <tt>Character</tt> subclass just stores a character code:
<pre>
class Character : public Glyph {
public:
    Character(char);

    virtual void Draw(Window*, GlyphContext&amp;);
private:
    char _charcode;
};
</pre>
<p>To keep from allocating space for a font attribute in every glyph,
we'll store the attribute extrinsically in a <tt>GlyphContext</tt>
object.  <tt>GlyphContext</tt> acts as a repository of extrinsic
state. It maintains a compact mapping between a glyph and its font
(and any other graphical attributes it might have) in different
contexts.  Any operation that needs to know the glyph's font in a
given context will have a <tt>GlyphContext</tt> instance passed to it
as a parameter.  The operation can then query the
<tt>GlyphContext</tt> for the font in that context.  The context
depends on the glyph's location in the glyph structure.  Therefore
<tt>Glyph</tt>'s child iteration and manipulation operations must
update the <tt>GlyphContext</tt> whenever they're used.</p>
<pre>
class GlyphContext {
public:
    GlyphContext();
    virtual ~GlyphContext();

    virtual void Next(int step = 1);
    virtual void Insert(int quantity = 1);

    virtual Font* GetFont();
    virtual void SetFont(Font*, int span = 1);
private:
    int _index;
    BTree* _fonts;
};
</pre>

<p><tt>GlyphContext</tt> must be kept informed of the current position
in the glyph structure during traversal.  <tt>GlyphContext::Next</tt>
increments <tt>_index</tt> as the traversal proceeds.
<tt>Glyph</tt> subclasses that have children (e.g., <tt>Row</tt> and
<tt>Column</tt>) must implement <tt>Next</tt> so that it calls
<tt>GlyphContext::Next</tt> at each point in the traversal.</p>
<p><tt>GlyphContext::GetFont</tt> uses the index as a key into a
<tt>BTree</tt> structure that stores the glyph-to-font mapping.
Each node in the tree is labeled with the length of the string for which
it gives font information.  Leaves in the tree point to a font, while
interior nodes break the string into substrings, one for each child.</p>
<p>Consider the following excerpt from a glyph composition:</p><p align=CENTER><img src="Pictures/btree097.gif"></p>
<p>The <tt>BTree</tt> structure for font information might look like</p><p align=CENTER><img src="Pictures/btree-1.gif"></p>
<p>Interior nodes define ranges of glyph indices. <tt>BTree</tt> is
updated in response to font changes and whenever glyphs are added to
or removed from the glyph structure.  For example, assuming we're at
index 102 in the traversal, the following code sets the font of each
character in the word "expect" to that of the surrounding text (that
is, <tt>times12</tt>, an instance of <tt>Font</tt> for 12-point
Times Roman):</p>
<pre>
GlyphContext gc;
Font* times12 = new Font("Times-Roman-12");
Font* timesItalic12 = new Font("Times-Italic-12");
// ...

gc.SetFont(times12, 6);
</pre>
<p>The new <tt>BTree</tt> structure (with changes shown in black) looks
like</p><p align=CENTER><img src="Pictures/btree-2.gif"></p>
<p>Suppose we add the word "don't&nbsp;" (including a trailing space) in
12-point Times Italic before "expect."  The following code informs the
<tt>gc</tt> of this event, assuming it is still at index 102:</p>
<pre>
gc.Insert(6);
gc.SetFont(timesItalic12, 6);
</pre>
<p>The <tt>BTree</tt> structure becomes</p><p align=CENTER><img src="Pictures/btree-3.gif"></p>
<p>When the <tt>GlyphContext</tt> is queried for the font of
the current glyph, it descends the <tt>BTree</tt>, adding up
indices as it goes until it finds the font for the current index.
Because the frequency of font changes is relatively low, the tree
stays small relative to the size of the glyph structure.  This
keeps storage costs down without an inordinate increase in look-up
time.<sup>3</sup></p>
<p>The last object we need is a FlyweightFactory that creates glyphs and
ensures they're shared properly.  Class <tt>GlyphFactory</tt>
instantiates <tt>Character</tt> and other kinds of glyphs.  We only
share <tt>Character</tt> objects; composite glyphs are far less
plentiful, and their important state (i.e., their children) is
intrinsic anyway.</p>
<pre>
const int NCHARCODES = 128;

class GlyphFactory {
public:
    GlyphFactory();
    virtual ~GlyphFactory();

    virtual Character* CreateCharacter(char);
    virtual Row* CreateRow();
    virtual Column* CreateColumn();
    // ...
private:
    Character* _character[NCHARCODES];
};
</pre>
<p>The <tt>_character</tt> array contains pointers to
<tt>Character</tt> glyphs indexed by character code.  The array is
initialized to zero in the constructor.</p>
<pre>
GlyphFactory::GlyphFactory () {
    for (int i = 0; i < NCHARCODES; ++i) {
         _character[i] = 0;
    }
}
</pre>
<p><tt>CreateCharacter</tt> looks up a character in the character
glyph in the array, and it returns the corresponding glyph if it
exists.  If it doesn't, then <tt>CreateCharacter</tt> creates
the glyph, puts it in the array, and returns it:</p>
<pre>
Character* GlyphFactory::CreateCharacter (char c) {
    if (!_character[c]) {
        _character[c] = new Character(c);
    }

    return _character[c];
}
</pre>
<p>The other operations simply instantiate a new object each time they're
called, since noncharacter glyphs won't be shared:</p>
<pre>
Row* GlyphFactory::CreateRow () {
    return new Row;
}

Column* GlyphFactory::CreateColumn () {
    return new Column;
}
</pre>
<p>We could omit these operations and let clients instantiate unshared
glyphs directly.  However, if we decide to make these glyphs sharable
later, we'll have to change client code that creates them.</p><a name="knownuses"><a>
<h3> Known Uses</h3> 

<p>The concept of flyweight objects was first described and explored as a
design technique in InterViews 3.0 [CL90]. Its
developers built a powerful document editor called Doc as a proof of
concept [CL92]. Doc uses glyph objects to represent each
character in the document.  The editor builds one Glyph instance for
each character in a particular style (which defines its graphical
attributes); hence a character's intrinsic state consists of the
character code and its style information (an index into a style
table).<sup>4</sup>
That means only position is extrinsic, making Doc fast.  Documents are
represented by a class Document, which also acts as the
FlyweightFactory.  Measurements on Doc have shown that sharing
flyweight characters is quite effective.  In a typical case, a
document containing 180,000 characters required allocation of only 480
character objects.</p>
<p>ET++ [WGM88] uses flyweights to support look-and-feel
independence.<sup>5</sup>
The look-and-feel standard affects the
layout of user interface elements (e.g., scroll bars, buttons,
menus&#151;known collectively as "widgets") and their decorations
(e.g., shadows, beveling).  A widget delegates all its layout and
drawing behavior to a separate Layout object.  Changing the Layout
object changes the look and feel, even at run-time.</p>
<p>For each widget class there is a corresponding Layout class (e.g.,
ScrollbarLayout, MenubarLayout, etc.). An obvious problem with this
approach is that using separate layout objects doubles the number of
user interface objects: For each user interface object there is an
additional Layout object.  To avoid this overhead, Layout objects are
implemented as flyweights.  They make good flyweights because they
deal mostly with defining behavior, and it's easy to pass them what
little extrinsic state they need to lay out or draw an object.</p>
<p>The Layout objects are created and managed by Look objects. The Look
class is an Abstract Factory  that
retrieves a specific Layout object with operations like
GetButtonLayout, GetMenuBarLayout, and so forth. For each
look-and-feel standard there is a corresponding Look subclass (e.g.,
MotifLook, OpenLook) that supplies the appropriate Layout objects.</p>
<p>By the way, Layout objects are essentially strategies (see
Strategy ). They are an example of a strategy
object implemented as a flyweight.</p>
<h3> Related Patterns</h3><p>The Flyweight pattern is often combined with the Composite  pattern to implement a
logically hierarchical structure in terms of a directed-acyclic
graph with shared leaf nodes.</p>
<p>It's often best to implement
State  and
Strategy 
objects as flyweights.</p>
<hr>
<p><sup>3</sup>Look-up time in
this scheme is proportional to the font change frequency.  Worst-case
performance occurs when a font change occurs on every character, but
that's unusual in practice.
</p>
<p><sup>4</sup>
In the Sample Code given earlier, style information is made
extrinsic, leaving the character code as the only intrinsic state.
</p>
<p><sup>5</sup>See Abstract Factory  for another approach to look-and-feel
independence.
</p><p>&nbsp;</p></body></html>

