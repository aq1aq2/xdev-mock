<html><head>	<title>Prototype</title><link href="ff.css" rel="stylesheet" type="text/css"></head><body>
<h2>Prototype</h2>
<h3> Intent</h3><p>Specify the kinds of objects to create using a prototypical
instance, and create new objects by copying this prototype.</p>
<h3> Motivation</h3><p>You could build an editor for music scores by customizing a general
framework for graphical editors and adding new objects that represent
notes, rests, and staves.  The editor framework may have a palette of
tools for adding these music objects to the score.  The palette would
also include tools for selecting, moving, and otherwise manipulating
music objects.  Users will click on the quarter-note tool and use it
to add quarter notes to the score.  Or they can use the move tool to
move a note up or down on the staff, thereby changing its pitch.</p>
<p>Let's assume the framework provides an abstract Graphic class for
graphical components, like notes and staves.  Moreover, it'll provide
an abstract Tool class for defining tools like those in the palette.
The framework also predefines a GraphicTool subclass for tools that
create instances of graphical objects and add them to the document.</p>
<p>But GraphicTool presents a problem to the framework designer.  The
classes for notes and staves are specific to our application, but the
GraphicTool class belongs to the framework.  GraphicTool doesn't know
how to create instances of our music classes to add to the score.  We
could subclass GraphicTool for each kind of music object, but that
would produce lots of subclasses that differ only in the kind of music
object they instantiate.  We know object composition is a flexible
alternative to subclassing.  The question is, how can the framework
use it to parameterize instances of GraphicTool by the <em>class</em> of
Graphic they're supposed to create?</p>
<p>The solution lies in making GraphicTool create a new Graphic by
copying or "cloning" an instance of a Graphic subclass.  We call
this instance a <b>prototype</b>.  GraphicTool is parameterized by the
prototype it should clone and add to the document.  If all Graphic
subclasses support a Clone operation, then the GraphicTool can clone
any kind of Graphic.</p>
<p>So in our music editor, each tool for creating a music object is an
instance of GraphicTool that's initialized with a different prototype.
Each GraphicTool instance will produce a music object by cloning its
prototype and adding the clone to the score.</p>
<p align=CENTER><img src="Pictures/proto019.gif"></p>
<p>We can use the Prototype pattern to reduce the number of classes even
further.  We have separate classes for whole notes and half notes, but
that's probably unnecessary.  Instead they could be instances of the
same class initialized with different bitmaps and durations.  A tool
for creating whole notes becomes just a GraphicTool whose prototype is
a MusicalNote initialized to be a whole note.  This can reduce the
number of classes in the system dramatically.  It also makes it easier
to add a new kind of note to the music editor.</p>
<h3> Applicability</h3><p>Use the Prototype pattern when a system should be independent of how
its products are created, composed, and represented; <em>and</em></p><ul>
<li>when the classes to instantiate are specified at run-time, for
example, by dynamic loading; <em>or</em></li>

<li>to avoid building a class hierarchy of factories that
parallels the class hierarchy of products; <em>or</em></li>

<li>when instances of a class can have one of only a few different
combinations of state.  It may be more convenient to install a
corresponding number of prototypes and clone them rather than
instantiating the class manually, each time with the appropriate state.</li></ul>
<h3> Structure</h3> <p align=CENTER><img src="Pictures/proto018.gif"></p>
<h3> Participants</h3><ul>
<li><b>Prototype</b> (Graphic)


<ul>
<li>declares an interface for cloning itself.</ul>



<li><b>ConcretePrototype</b> (Staff, WholeNote, HalfNote)


<ul>
<li>implements an operation for cloning itself.</ul>



<li><b>Client</b> (GraphicTool)


<ul>

<li>creates a new object by asking a prototype to clone itself.</ul></ul>
<h3> Collaborations</h3><ul>
<li>A client asks a prototype to clone itself.</ul>
<h3> Consequences</h3><p>Prototype has many of the same consequences that Abstract Factory  and Builder 
have: It hides the concrete product classes from the client, thereby
reducing the number of names clients know about.  Moreover, these
patterns let a client work with application-specific classes without
modification.</p>
<p>Additional benefits of the Prototype pattern are listed below.</p><ol>
<li><em>Adding and removing products at run-time.</em>
Prototypes let you incorporate a new concrete product class into a
system simply by registering a prototypical instance with the client.
That's a bit more flexible than other creational patterns, because a
client can install and remove prototypes at run-time.</li>



<li><em>Specifying new objects by varying values.</em>
Highly dynamic systems let you define new behavior through object
composition&#151;by specifying values for an object's variables, for
example&#151;and not by defining new classes.  You effectively define new
kinds of objects by instantiating existing classes and registering the
instances as prototypes of client objects.  A client can exhibit new
behavior by delegating responsibility to the prototype.
<p>This kind of design lets users define new "classes" without
programming.  In fact, cloning a prototype is similar to instantiating
a class.  The Prototype pattern can greatly reduce the number of
classes a system needs.  In our music editor, one GraphicTool class
can create a limitless variety of music objects.</p></li>



<li><em>Specifying new objects by varying structure.</em>
Many applications build objects from parts and subparts.  Editors for
circuit design, for example, build circuits out of
subcircuits.<sup>1</sup>
For convenience, such applications often let you
instantiate complex, user-defined structures, say, to use a specific
subcircuit again and again.
<p>The Prototype pattern supports this as well.  We simply add this
subcircuit as a prototype to the palette of available circuit
elements.  As long as the composite circuit object implements Clone as
a deep copy, circuits with different structures can be prototypes.</li>



<li><em>Reduced subclassing.</em>
Factory Method  often produces a hierarchy of
Creator classes that parallels the product class hierarchy.  The
Prototype pattern lets you clone a prototype instead of asking a
factory method to make a new object.  Hence you don't need a Creator
class hierarchy at all.  This benefit applies primarily to languages
like C++ that don't treat classes as first-class objects.  Languages
that do, like Smalltalk and Objective C, derive less benefit, since
you can always use a class object as a creator.  Class objects already
act like prototypes in these languages.</li>



<li><em>Configuring an application with classes dynamically.</em>
Some run-time environments let you load classes into an application
dynamically.  The Prototype pattern is the key to exploiting such
facilities in a language like C++.
<p>An application that wants to create instances of a dynamically loaded
class won't be able to reference its constructor statically.  Instead,
the run-time environment creates an instance of each class
automatically when it's loaded, and it registers the instance with a
prototype manager (see the Implementation section).  Then the
application can ask the prototype manager for instances of
newly loaded classes, classes that weren't linked with the program
originally.  The ET++ application framework [WGM88] has a run-time
system that uses this scheme.</li></ol>
<p>The main liability of the Prototype pattern is that each subclass of
Prototype must implement the <tt>Clone</tt> operation, which may be
difficult.  For example, adding <tt>Clone</tt> is difficult when the
classes under consideration already exist.  Implementing <tt>Clone</tt> can be
difficult when their internals include objects that don't support
copying or have circular references.</p>
<h3> Implementation</h3><p>Prototype is particularly useful with static languages like C++, where
classes are not objects, and little or no type information is
available at run-time.  It's less important in languages like
Smalltalk or Objective C that provide what amounts to a prototype
(i.e., a class object) for creating instances of each class.  This
pattern is built into prototype-based languages like
Self [US87], in which all object creation happens by
cloning a prototype.</p>
<p>Consider the following issues when implementing prototypes:</p><ol>
<li><em>Using a prototype manager.</em>
When the number of prototypes in a system isn't fixed (that is, they
can be created and destroyed dynamically), keep a registry of
available prototypes.  Clients won't manage prototypes themselves but
will store and retrieve them from the registry.  A client will ask the
registry for a prototype before cloning it.  We call this registry a
<strong>prototype manager</strong>.
<p>A prototype manager is an associative store that returns the prototype
matching a given key.  It has operations for registering a prototype
under a key and for unregistering it.  Clients can change or even
browse through the registry at run-time.  This lets clients extend and
take inventory on the system without writing code.</li>

<li><em>Implementing the Clone operation.</em>
The hardest part of the Prototype pattern is implementing the Clone
operation correctly.  It's particularly tricky when object structures
contain circular references.
<p>Most languages provide some support for cloning objects.  For example,
Smalltalk provides an implementation of <tt>copy</tt> that's
inherited by all subclasses of Object.  C++ provides a copy
constructor.  But these facilities don't solve the "shallow copy
versus deep copy" problem [GR83].  That is, does cloning an
object in turn clone its instance variables, or do the clone and
original just share the variables?
<p>A shallow copy is simple and often sufficient, and that's what
Smalltalk provides by default.  The default copy constructor in C++
does a member-wise copy, which means pointers will be shared between
the copy and the original.  But cloning prototypes with complex
structures usually requires a deep copy, because the clone and the
original must be independent.  Therefore you must ensure that the
clone's components are clones of the prototype's components.  Cloning
forces you to decide what if anything will be shared.
<p>If objects in the system provide Save and Load operations, then you
can use them to provide a default implementation of Clone simply by
saving the object and loading it back immediately.  The Save operation
saves the object into a memory buffer, and Load creates a duplicate by
reconstructing the object from the buffer.</li>

<li><em>Initializing clones.</em>
While some clients are perfectly happy with the clone as is, others
will want to initialize some or all of its internal state to values of
their choosing.  You generally can't pass these values in the Clone
operation, because their number will vary between classes of
prototypes.  Some prototypes might need multiple initialization
parameters; others won't need any.  Passing parameters in the Clone
operation precludes a uniform cloning interface.
<p>It might be the case that your prototype classes already define
operations for (re)setting key pieces of state.  If so, clients may
use these operations immediately after cloning.  If not, then you may
have to introduce an <tt>Initialize</tt> operation (see the Sample
Code section) that takes initialization parameters as arguments and
sets the clone's internal state accordingly.  Beware of deep-copying
Clone operations&#151;the copies may have to be deleted (either
explicitly or within <tt>Initialize</tt>) before you reinitialize
them.</li></ol><a name="samplecode"><a>
<h3> Sample Code</h3>
<p>We'll define a <tt>MazePrototypeFactory</tt> subclass of the
<tt>MazeFactory</tt> class.
<tt>MazePrototypeFactory</tt> will be initialized with prototypes of the
objects it will create so that we don't have to subclass it just to
change the classes of walls or rooms it creates.</p>
<p><tt>MazePrototypeFactory</tt> augments the <tt>MazeFactory</tt>
interface with a constructor that takes the prototypes as arguments:</p>
<pre>
class MazePrototypeFactory : public MazeFactory {
public:
    MazePrototypeFactory(Maze*, Wall*, Room*, Door*);

    virtual Maze* MakeMaze() const;
    virtual Room* MakeRoom(int) const;
    virtual Wall* MakeWall() const;
    virtual Door* MakeDoor(Room*, Room*) const;

private:
    Maze* _prototypeMaze;
    Room* _prototypeRoom;
    Wall* _prototypeWall;
    Door* _prototypeDoor;
};
</pre>
<p>The new constructor simply initializes its prototypes:</p>
<pre>
MazePrototypeFactory::MazePrototypeFactory (
    Maze* m, Wall* w, Room* r, Door* d
) {
   _prototypeMaze = m;
   _prototypeWall = w;
   _prototypeRoom = r;
   _prototypeDoor = d;
}
</pre>
<p>The member functions for creating walls, rooms, and doors are similar:
Each clones a prototype and then initializes it.  Here are the
definitions of <tt>MakeWall</tt> and <tt>MakeDoor</tt>:</p>
<pre>
Wall* MazePrototypeFactory::MakeWall () const {
    return _prototypeWall->Clone();
}

Door* MazePrototypeFactory::MakeDoor (Room* r1, Room *r2) const {
    Door* door = _prototypeDoor->Clone();
    door->Initialize(r1, r2);
    return door;
}
</pre>
<p>We can use <tt>MazePrototypeFactory</tt> to create a prototypical or
default maze just by initializing it with prototypes of basic maze
components:</P.

>
<pre>
MazeGame game;
MazePrototypeFactory simpleMazeFactory(
    new Maze, new Wall, new Room, new Door
);

Maze* maze = game.CreateMaze(simpleMazeFactory);
</pre>
<p>To change the type of maze, we initialize
<tt>MazePrototypeFactory</tt> with a different set of prototypes.
The following call creates a maze with a <tt>BombedDoor</tt> and a
<tt>RoomWithABomb</tt>:</p>
<pre>
MazePrototypeFactory bombedMazeFactory(
    new Maze, new BombedWall,
    new RoomWithABomb, new Door
);
</pre>
<p>An object that can be used as a prototype, such as an instance of
<tt>Wall</tt>, must support the <tt>Clone</tt> operation.  It must
also have a copy constructor for cloning.  It may also need a separate
operation for reinitializing internal state.  We'll add the
<tt>Initialize</tt> operation to <tt>Door</tt> to let clients
initialize the clone's rooms.</p>
<p>Compare the following definition of <tt>Door</tt> to the one on
:
<pre>
class Door : public MapSite {
public:
    Door();
    Door(const Door&amp;);

    virtual void Initialize(Room*, Room*);
    virtual Door* Clone() const;

    virtual void Enter();
    Room* OtherSideFrom(Room*);
private:
    Room* _room1;
    Room* _room2;
};

Door::Door (const Door&amp; other) {
    _room1 = other._room1;
    _room2 = other._room2;
}

void Door::Initialize (Room* r1, Room* r2) {
    _room1 = r1;
    _room2 = r2;
}

Door* Door::Clone () const {
    return new Door(*this);
}
</pre>
<p>The  <tt>BombedWall</tt> subclass must override <tt>Clone</tt> and
implement a corresponding copy constructor.</p>
<pre>
class BombedWall : public Wall {
public:
    BombedWall();
    BombedWall(const BombedWall&amp;);

    virtual Wall* Clone() const;
    bool HasBomb();
private:
    bool _bomb;
};

BombedWall::BombedWall (const BombedWall&amp; other) : Wall(other) {
    _bomb = other._bomb;
}

Wall* BombedWall::Clone () const {
    return new BombedWall(*this);
}
</pre>
<p>Although <tt>BombedWall::Clone</tt> returns a <tt>Wall*</tt>, its
implementation returns a pointer to a new instance of a subclass, that
is, a <tt>BombedWall*</tt>.  We define <tt>Clone</tt> like this in
the base class to ensure that clients that clone the prototype don't
have to know about their concrete subclasses.  Clients should never
need to downcast the return value of <tt>Clone</tt> to the desired
type.</p>
<p>In Smalltalk, you can reuse the standard <tt>copy</tt> method
inherited from <tt>Object</tt> to clone any <tt>MapSite</tt>.  You
can use <tt>MazeFactory</tt> to produce the prototypes you'll need;
for example, you can create a room by supplying the name
<tt>#room</tt>.  The <tt>MazeFactory</tt> has a dictionary
that maps names to prototypes.  Its <tt>make:</tt> method looks like
this:</p>
<pre>
make: partName
    ^ (partCatalog at: partName) copy
</pre>
<p>Given appropriate methods for initializing the <tt>MazeFactory</tt>
with prototypes, you could create a simple maze with the following code:</p>
<pre>
CreateMaze
    on: (MazeFactory new
        with: Door new named: #door;
        with: Wall new named: #wall;
        with: Room new named: #room;
        yourself)
</pre>
<p>where the definition of the <tt>on:</tt> class method for
<tt>CreateMaze</tt> would be</p>
<pre>
on: aFactory
    | room1 room2 |
    room1 := (aFactory make: #room) location: 1@1.
    room2 := (aFactory make: #room) location: 2@1.
    door := (aFactory make: #door) from: room1 to: room2.

    room1
        atSide: #north put: (aFactory make: #wall);
        atSide: #east put: door;
        atSide: #south put: (aFactory make: #wall);
        atSide: #west put: (aFactory make: #wall).
    room2
        atSide: #north put: (aFactory make: #wall);
        atSide: #east put: (aFactory make: #wall);
        atSide: #south put: (aFactory make: #wall);
        atSide: #west put: door.
    ^ Maze new
        addRoom: room1;
        addRoom: room2;
        yourself
</pre><a name="knownuses"><a>
<h3> Known Uses</h3><p>Perhaps the first example of the Prototype pattern was in Ivan
Sutherland's Sketchpad system [Sut63].  The first widely known
application of the pattern in an object-oriented language was in
ThingLab, where users could form a composite object and then promote
it to a prototype by installing it in a library of reusable
objects [Bor81].
Goldberg and Robson mention prototypes as a pattern [GR83], but Coplien [Cop92] gives a much more complete
description.  He describes idioms related to the Prototype pattern
for C++ and gives many examples and variations.</p>



<p>Etgdb is a debugger front-end based on ET++ that provides a
point-and-click interface to different line-oriented debuggers.
Each debugger has a corresponding DebuggerAdaptor subclass.  For
example, GdbAdaptor adapts etgdb to the command syntax of GNU gdb,
while SunDbxAdaptor adapts etgdb to Sun's dbx debugger.  Etgdb does
not have a set of DebuggerAdaptor classes hard-coded into it.
Instead, it reads the name of the adaptor to use from an environment
variable, looks for a prototype with the specified name in a global
table, and then clones the prototype.  New debuggers can be added
to etgdb by linking it with the DebuggerAdaptor that works for that
debugger.</p>
<p>The "interaction technique library" in Mode Composer stores
prototypes of objects that support various interaction techniques [Sha90].  Any interaction technique created
by the Mode Composer can be used as a prototype by placing it in
this library.  The Prototype pattern lets Mode Composer support an
unlimited set of interaction techniques.</p>
<p>The music editor example discussed earlier is based on the
Unidraw drawing framework [VL90].</p>
<h3> Related Patterns</h3><p>Prototype and Abstract Factory  are competing patterns in some ways, as we
discuss at the end of this chapter.  They can also be used together,
however.  An Abstract Factory might store a set of prototypes from
which to clone and return product objects.</p>
<p>Designs that make heavy use of the Composite  and Decorator  patterns often can benefit
from Prototype as well.</p>
<hr>
<p><sup>1</sup>Such applications reflect the Composite  and Decorator 
patterns.
</p><p>&nbsp;</p></body></html>

