<html><head>	<title>Template Method</title><link href="ff.css" rel="stylesheet" type="text/css"></head><body>
<h2>Template Method</h2>
<h3> Intent</h3><p>Define the skeleton of an algorithm in an operation, deferring some
steps to subclasses. Template Method lets subclasses redefine
certain steps of an algorithm without changing the algorithm's
structure.</p>
<h3> Motivation</h3><p>Consider an application framework that provides Application and
Document classes.  The Application class is responsible for opening
existing documents stored in an external format, such as a file.  A
Document object represents the information in a document once it's
read from the file.</p>
<p>Applications built with the framework can subclass Application and
Document to suit specific needs.  For example, a drawing application
defines DrawApplication and DrawDocument subclasses; a spreadsheet
application defines SpreadsheetApplication and SpreadsheetDocument
subclasses.
<p align=CENTER><img src="Pictures/tmeth007.gif"></p>
<p>The abstract Application class defines the algorithm for opening and
reading a document in its OpenDocument operation:</p>
<pre>
void Application::OpenDocument (const char* name) {
    if (!CanOpenDocument(name)) {
        // cannot handle this document
        return;
    }

    Document* doc = DoCreateDocument();

    if (doc) {
        _docs->AddDocument(doc);
        AboutToOpenDocument(doc);
        doc->Open();
        doc->DoRead();
    }
}
</pre>
<p>OpenDocument defines each step for opening a document.  It checks if
the document can be opened, creates the application-specific Document
object, adds it to its set of documents, and reads the Document from a
file.</p>
<p>We call OpenDocument a <strong>template method</strong>.  A template method
defines an algorithm in terms of abstract operations that subclasses
override to provide concrete behavior.  Application subclasses define
the steps of the algorithm that check if the document can be opened
(CanOpenDocument) and that create the Document (DoCreateDocument).
Document classes define the step that reads the document (DoRead).
The template method also defines an operation that lets Application
subclasses know when the document is about to be opened
(AboutToOpenDocument), in case they care.</p>
<p>By defining some of the steps of an algorithm using abstract
operations, the template method fixes their ordering, but it lets
Application and Document subclasses vary those steps to suit their
needs.</p>
<h3> Applicability</h3><p>The Template Method pattern should be used</p><ul>
<li>to implement the invariant parts of an algorithm once and leave it up
to subclasses to implement the behavior that can vary.</li>



<li>when common behavior among subclasses should be factored and localized
in a common class to avoid code duplication. This is a good example of
"refactoring to generalize" as described by Opdyke and
Johnson [OJ93].  You first identify the
differences in the existing code and then separate the differences
into new operations.  Finally, you replace the differing code with a
template method that calls one of these new operations.</li>



<li>to control subclasses extensions. You can define a template method
that calls "hook" operations (see Consequences) at specific points,
thereby permitting extensions only at those points.</li></ul>
<h3> Structure</h3> <p align=CENTER><img src="Pictures/tmethod.gif"></p>
<h3> Participants</h3><ul>
<li><b>AbstractClass</b> (Application)


<ul>
<li>defines abstract <strong>primitive operations</strong> that concrete
subclasses define to implement steps of an algorithm.</li>



<li>implements a template method defining the skeleton of an algorithm.
The template method calls primitive operations as well as operations
defined in AbstractClass or those of other objects.</li></ul>



<li><b>ConcreteClass</b> (MyApplication)


<ul>
<li>implements the primitive operations to carry out subclass-specific
steps of the algorithm.</li></ul></ul>
<h3> Collaborations</h3><ul>
<li>ConcreteClass relies on AbstractClass to implement the invariant steps of 
the algorithm.</li></ul>
<h3> Consequences</h3><p>Template methods are a fundamental technique for code reuse.  They are
particularly important in class libraries, because they are the means
for factoring out common behavior in library classes.</p>
<p>Template methods lead to an inverted control structure that's
sometimes referred to as "the Hollywood principle," that is, "Don't
call us, we'll call you" [Swe85].  This refers to
how a parent class calls the operations of a subclass and not the
other way around.</p>
<p>Template methods call the following kinds of operations:</p><ul>
<li>concrete operations (either on the ConcreteClass or on
client classes);</li>



<li>concrete AbstractClass operations (i.e., operations that are
generally useful to subclasses);</li>



<li>primitive operations (i.e., abstract operations);</li>



<li>factory methods (see Factory Method );
and</li>



<li><strong>hook operations</strong>, which provide default behavior that
subclasses can extend if necessary. A hook operation often does
nothing by default.</li></ul>
<p>It's important for template methods to specify which operations are
hooks (<em>may</em> be overridden) and which are abstract operations
(<em>must</em> be overridden). To reuse an abstract class effectively,
subclass writers must understand which operations are designed for
overriding.</p>
<p>A subclass can <em>extend</em> a parent class operation's behavior by
overriding the operation and calling the parent operation explicitly:
<pre>
void DerivedClass::Operation () {
    // DerivedClass extended behavior
    ParentClass::Operation();
}
</pre>
<p>Unfortunately, it's easy to forget to call the inherited operation.
We can transform such an operation into a template method to give
the parent control over how subclasses extend it. The idea is to
call a hook operation from a template method in the parent class.
Then subclasses can then override this hook operation:</p>
<pre>
void ParentClass::Operation () {
    // ParentClass behavior
    HookOperation();
}
</pre>
<p><tt>HookOperation</tt> does nothing in <tt>ParentClass</tt>:</p>
<pre>
void ParentClass::HookOperation () { }
</pre>
<p>Subclasses override <tt>HookOperation</tt> to extend its
behavior:</p>
<pre>
void DerivedClass::HookOperation () {
     // derived class extension
}
</pre>
<h3> Implementation</h3><p>Three implementation issues are worth noting:</p><ol>
<li><em>Using C++ access control.</em>
In C++, the primitive operations that a template method calls can be
declared protected members. This ensures that they are only called by
the template method. Primitive operations that <em>must</em> be overridden are
declared pure virtual. The template method itself should not be
overridden; therefore you can make the template method a nonvirtual
member function.</li>



<li><em>Minimizing primitive operations.</em>
An important goal in designing template methods is to minimize the
number of primitive operations that a subclass must override to flesh
out the algorithm. The more operations that need overriding, the more
tedious things get for clients.</li>



<li><em>Naming conventions.</em>
You can identify the operations that should be overridden by adding a
prefix to their names. For example, the MacApp framework for Macintosh
applications [App89] prefixes template method names with "Do-":
"DoCreateDocument", "DoRead", and so forth.</li></ol><a name="samplecode"><a>
<h3> Sample Code</h3><p>The following C++ example shows how a parent class can enforce an
invariant for its subclasses. The example comes from NeXT's
AppKit [Add94]. Consider a class <tt>View</tt> that supports
drawing on the screen. <tt>View</tt> enforces the invariant that its
subclasses can draw into a view only after it becomes the "focus,"
which requires certain drawing state (for example, colors and fonts) to
be set up properly.</p>
<p>We can use a <tt>Display</tt> template method to set up this state.
<tt>View</tt> defines two concrete operations,
<tt>SetFocus</tt> and <tt>ResetFocus</tt>, that set up and clean up
the drawing state, respectively.  <tt>View</tt>'s <tt>DoDisplay</tt>
hook operation performs the actual drawing.  <tt>Display</tt> calls
<tt>SetFocus</tt> before <tt>DoDisplay</tt> to set up the drawing
state; <tt>Display</tt> calls <tt>ResetFocus</tt> afterwards to
release the drawing state.</p>
<pre>
void View::Display () {
    SetFocus();
    DoDisplay();
    ResetFocus();
}
</pre>
<p>To maintain the invariant, the <tt>View</tt>'s clients always call
<tt>Display</tt>, and <tt>View</tt> subclasses always override
<tt>DoDisplay</tt>.</p>
<p><tt>DoDisplay</tt> does nothing in <tt>View</tt>:</p>
<pre>
void View::DoDisplay () { }
</pre>
<p>Subclasses override it to add their specific drawing behavior:</p>
<pre>
void MyView::DoDisplay () {
    // render the view's contents
}
</pre><a name="knownuses"><a>
<h3> Known Uses</h3><p>Template methods are so fundamental that they can be found in almost
every abstract class.  Wirfs-Brock et al. [WBWW90,
 WBJ90] provide a good overview and
discussion of template methods.</p>
<h3> Related Patterns</h3><p>Factory Methods (107)
are often called by template methods. In the Motivation example,
the factory method DoCreateDocument is called by the template method
OpenDocument.</p>
<p>Strategy :
Template methods use inheritance to vary part of an algorithm.
Strategies use delegation to vary the entire algorithm.</p>
<p>&nbsp;</p></body></html>
