<html><head><title>Strategy</title><link href="ff.css" rel="stylesheet" type="text/css"></head><body>
<h2>Strategy</h2>
<h3> Intent</h3><p>Define a family of algorithms, encapsulate each one, and make them
interchangeable.  Strategy lets the algorithm vary independently from
clients that use it.</p>
<h3> Also Known As</h3><p>Policy</p>
<h3> Motivation</h3><p>Many algorithms exist for breaking a stream of text into lines.
Hard-wiring all such algorithms into the classes that require them
isn't desirable for several reasons:</p><ul>
<li>Clients that need linebreaking get more complex if they include
the linebreaking code.  That makes clients bigger and harder to
maintain, especially if they support multiple linebreaking algorithms.</li>



<li>Different algorithms will be appropriate at different times.  We don't
want to support multiple linebreaking algorithms if we don't use them
all.</li>



<li>It's difficult to add new algorithms and vary existing ones when
linebreaking is an integral part of a client.</li></ul>
<p>We can avoid these problems by defining classes that encapsulate
different linebreaking algorithms. An algorithm that's encapsulated in
this way is called a <strong>strategy</strong>.</p>
<p align=CENTER><img src="Pictures/strat011.gif"></p>
<p>Suppose a Composition class is responsible for maintaining and
updating the linebreaks of text displayed in a text viewer.
Linebreaking strategies aren't implemented by the class Composition.
Instead, they are implemented separately by subclasses of the abstract
Compositor class. Compositor subclasses implement different strategies:</p><ul>
<li><strong>SimpleCompositor</strong>
implements a simple strategy that determines linebreaks one at a
time.</li>



<li><strong>TeXCompositor</strong>
implements the TeX algorithm for finding linebreaks. This strategy
tries to optimize linebreaks globally, that is, one paragraph at a
time.</li>



<li><strong>ArrayCompositor</strong>
implements a strategy that selects breaks so that each row has a fixed
number of items.  It's useful for breaking a collection of icons into
rows, for example.</li></ul>
<p>A Composition maintains a reference to a Compositor object. Whenever a
Composition reformats its text, it forwards this responsibility to its
Compositor object. The client of Composition specifies which
Compositor should be used by installing the Compositor it desires into
the Composition.</p>
<h3> Applicability</h3><p>Use the Strategy pattern when</p><ul>
<li>many related classes differ only in their behavior.  Strategies
provide a way to configure a class with one of many behaviors.</li>

<li>you need different variants of an algorithm. For example, you might define
algorithms reflecting different space/time trade-offs.
Strategies can be used when these variants are implemented as a class
hierarchy of algorithms [HO87].</li>

<li>an algorithm uses data that clients shouldn't know about. Use the
Strategy pattern to avoid exposing complex, algorithm-specific data
structures.</li>

<li>a class defines many behaviors, and these appear as multiple
conditional statements in its operations. Instead of many
conditionals, move related conditional branches into their own
Strategy class.</li></ul>
<h3> Structure</h3><p align=CENTER><img src="Pictures/strategy.gif"></p>
<h3> Participants</h3><ul>
<li><b>Strategy</b> (Compositor)</li>


<ul>
<li>declares an interface common to all supported algorithms.
Context uses this interface to call the
algorithm defined by a ConcreteStrategy.</li></ul>



<li><b>ConcreteStrategy</b> (SimpleCompositor, TeXCompositor,
ArrayCompositor)</li>


<ul>
<li>implements the algorithm using the Strategy interface.</li></ul>



<li><b>Context</b> (Composition)


<ul>
<li>is configured with a ConcreteStrategy object.</li>
<p><!-- extra space --></p>
<li>maintains a reference to a Strategy object.</li>
<p><!-- extra space --></p>
<li>may define an interface that lets Strategy access its data.</li></ul></ul>
<h3> Collaborations</h3><ul>
<li>Strategy and Context interact to implement the chosen algorithm.  A
context may pass all data required by the algorithm to the strategy
when the algorithm is called. Alternatively, the context can pass
itself as an argument to Strategy operations. That lets the strategy
call back on the context as required.</li>

<li>A context forwards requests from its clients to its strategy.  Clients
usually create and pass a ConcreteStrategy object to the context;
thereafter, clients interact with the context exclusively. There is
often a family of ConcreteStrategy classes for a client to choose
from.</li></ul>
<h3> Consequences</h3><p>The Strategy pattern has the following benefits and drawbacks:</p><ol>
<li><em>Families of related algorithms.</em>
Hierarchies of Strategy classes define a family of algorithms or
behaviors for contexts to reuse. Inheritance can
help factor out common functionality of the algorithms.</li>

<li><em>An alternative to subclassing.</em>
Inheritance offers another way to support a variety of algorithms or
behaviors. You can subclass a Context class directly to give it
different behaviors. But this hard-wires the behavior into Context.
It mixes the algorithm implementation with Context's, making Context
harder to understand, maintain, and extend. And you can't vary the
algorithm dynamically. You wind up with many related classes whose
only difference is the algorithm or behavior they employ.
Encapsulating the algorithm in separate Strategy classes lets you vary
the algorithm independently of its context, making it easier to
switch, understand, and extend.</li>

<li><em>Strategies eliminate conditional statements.</em>
The Strategy pattern offers an alternative to conditional statements for
selecting desired behavior. When different behaviors are lumped into one
class, it's hard to avoid using conditional statements to select the
right behavior. Encapsulating the behavior in separate Strategy classes
eliminates these conditional statements.
<p>For example, without strategies, the code for breaking
text into lines could look like
<pre>
void Composition::Repair () {
    switch (_breakingStrategy) {
    case SimpleStrategy:
        ComposeWithSimpleCompositor();
        break;
    case TeXStrategy:
        ComposeWithTeXCompositor();
        break;
    // ...
    }
    // merge results with existing composition, if necessary
}
</pre>
<p>The Strategy pattern eliminates this case statement by delegating the
linebreaking task to a Strategy object:</p>
<pre>
void Composition::Repair () {
    _compositor->Compose();
    // merge results with existing composition, if necessary
}
</pre>
<p>Code containing many conditional statements often indicates
the need to apply the Strategy pattern.</p></li>

<li><em>A choice of implementations.</em>
Strategies can provide different implementations of the <em>same</em>
behavior. The client can choose among strategies with different
time and space trade-offs.</li>

<li><em>Clients must be aware of different Strategies.</em>
The pattern has a potential drawback in that a client must understand
how Strategies differ before it can select the appropriate one.
Clients might be exposed to implementation issues.  Therefore you
should use the Strategy pattern only when the variation in behavior is
relevant to clients.</li>

<li><em>Communication overhead between Strategy and Context.</em>
The Strategy interface is shared by all ConcreteStrategy classes
whether the algorithms they implement are trivial or complex.  Hence
it's likely that some ConcreteStrategies won't use all the information
passed to them through this interface; simple ConcreteStrategies may
use none of it!  That means there will be times when the context
creates and initializes parameters that never get used. If this is an
issue, then you'll need tighter coupling between Strategy and Context.</li>

<li><em>Increased number of objects.</em>
Strategies increase the number of objects in an application. Sometimes
you can reduce this overhead by implementing strategies as stateless
objects that contexts can share. Any residual state is maintained by the
context, which passes it in each request to the Strategy object. Shared
strategies should not maintain state across invocations. The
Flyweight (195) pattern describes this approach in more
detail.</li></ol>
<h3> Implementation</h3><p>Consider the following implementation issues:</p><ol>
<li><em>Defining the Strategy and Context interfaces.</em>
The Strategy and Context interfaces must give a ConcreteStrategy
efficient access to any data it needs from a context, and vice versa.
<p>One approach is to have Context pass data in parameters to Strategy
operations&#151;in other words, take the data to the strategy. This keeps
Strategy and Context decoupled. On the other hand, Context might
pass data the Strategy doesn't need.</p>
<p>Another technique has a context pass <em>itself</em> as an argument, and
the strategy requests data from the context explicitly.
Alternatively, the strategy can store a reference to its context,
eliminating the need to pass anything at all.  Either way, the
strategy can request exactly what it needs.  But now Context must
define a more elaborate interface to its data, which couples Strategy
and Context more closely.</p>
<p>The needs of the particular algorithm and its data requirements will
determine the best technique.</p></li>
<li><em>Strategies as template parameters.</em>
In C++ templates can be used to configure a class with a strategy.
This technique is only applicable if (1) the Strategy can be selected
at compile-time, and (2) it does not have to be changed at run-time.
In this case, the class to be configured (e.g., <tt>Context</tt>) is
defined as a template class that has a <tt>Strategy</tt> class as a
parameter:
<pre>
template &lt;class AStrategy>
class Context {
    void Operation() { theStrategy.DoAlgorithm(); }
    // ...
private:
    AStrategy theStrategy;
};
</pre>
The class is then configured with a <tt>Strategy</tt> class when it's
instantiated:<pre>
class MyStrategy {
public:
    void DoAlgorithm();
};

Context&lt;MyStrategy> aContext;
</pre>
With templates, there's no need to define an abstract class that defines
the interface to the <tt>Strategy.</tt> Using <tt>Strategy</tt> as a
template parameter also lets you bind a <tt>Strategy</tt> to its
<tt>Context</tt> statically, which can increase efficiency.</P></li>
<li><em>Making Strategy objects optional.</em>
The Context class may be simplified if it's meaningful <em>not</em> to
have a Strategy object.  Context checks to see if it has a Strategy
object before accessing it.  If there is one, then Context uses it
normally.  If there isn't a strategy, then Context carries out default
behavior.  The benefit of this approach is that clients don't have to
deal with Strategy objects at all <em>unless</em> they don't like the
default behavior.</li></ol><a name="samplecode"><a>
<h3> Sample Code</h3><p>We'll give the high-level code for the Motivation example, which is
based on the implementation of Composition and Compositor classes in
InterViews [LCI+92].</p>

<p>The <tt>Composition</tt> class maintains a collection of
<tt>Component</tt> instances, which represent text and graphical
elements in a document.  A composition arranges component objects into
lines using an instance of a <tt>Compositor</tt> subclass, which
encapsulates a linebreaking strategy.  Each component has an
associated natural size, stretchability, and shrinkability. The
stretchability defines how much the component can grow beyond its
natural size; shrinkability is how much it can shrink.  The
composition passes these values to a compositor, which uses them to
determine the best location for linebreaks.</p>
<pre>
class Composition {
public:
    Composition(Compositor*);
    void Repair();
private:
    Compositor* _compositor;
    Component* _components;    // the list of components
    int _componentCount;       // the number of components
    int _lineWidth;            // the Composition's line width
    int* _lineBreaks;          // the position of linebreaks
                               // in components
    int _lineCount;            // the number of lines
};
</pre>
<p>When a new layout is required, the composition asks its compositor to
determine where to place linebreaks. The composition passes the
compositor three arrays that define natural sizes, stretchabilities,
and shrinkabilities of the components.  It also passes the number of
components, how wide the line is, and an array that the compositor
fills with the position of each linebreak.  The compositor returns the
number of calculated breaks.</p>
<p>The <tt>Compositor</tt> interface lets the composition pass the
compositor all the information it needs.  This is an example of
"taking the data to the strategy":</p>
<pre>
class Compositor {
public:
    virtual int Compose(
        Coord natural[], Coord stretch[], Coord shrink[],
        int componentCount, int lineWidth, int breaks[]
    ) = 0;
protected:
    Compositor();
};
</pre>
<p>Note that <tt>Compositor</tt> is an abstract class.  Concrete
subclasses define specific linebreaking strategies.</p>
<p>The composition calls its compositor in its <tt>Repair</tt>
operation.  <tt>Repair</tt> first initializes arrays with the natural
size, stretchability, and shrinkability of each component (the details
of which we omit for brevity).  Then it calls on the compositor to
obtain the linebreaks and finally lays out the components according to
the breaks (also omitted):</p>
<pre>
void Composition::Repair () {
    Coord* natural;
    Coord* stretchability;
    Coord* shrinkability;
    int componentCount;
    int* breaks;

    // prepare the arrays with the desired component sizes
    // ...

    // determine where the breaks are:
    int breakCount;
    breakCount = _compositor->Compose(
        natural, stretchability, shrinkability,
        componentCount, _lineWidth, breaks
    );

    // lay out components according to breaks
    // ...
}
</pre>
<p>Now let's look at the <tt>Compositor</tt> subclasses.
<tt>SimpleCompositor</tt> examines components a line at a time to
determine where breaks should go:</p>
<pre>
class SimpleCompositor : public Compositor {
public:
    SimpleCompositor();

    virtual int Compose(
        Coord natural[], Coord stretch[], Coord shrink[],
        int componentCount, int lineWidth, int breaks[]
    );
    // ...
};
</pre>

<p><tt>TeXCompositor</tt> uses a more global strategy.  It examines a
<em>paragraph</em> at a time, taking into account the components' size
and stretchability.  It also tries to give an even "color" to the
paragraph by minimizing the whitespace between components.</p>
<pre>
class TeXCompositor : public Compositor {
public:
    TeXCompositor();

    virtual int Compose(
        Coord natural[], Coord stretch[], Coord shrink[],
        int componentCount, int lineWidth, int breaks[]
    );
    // ...
};
</pre>
<p><tt>ArrayCompositor</tt> breaks the components into lines at regular
intervals.</p>
<pre>
class ArrayCompositor : public Compositor {
public:
    ArrayCompositor(int interval);

    virtual int Compose(
        Coord natural[], Coord stretch[], Coord shrink[],
        int componentCount, int lineWidth, int breaks[]
    );
    // ...
};
</pre>
<p>These classes don't use all the information passed in
<tt>Compose</tt>.  <tt>SimpleCompositor</tt> ignores the stretchability
of the components, taking only their natural widths into account.
<tt>TeXCompositor</tt> uses all the information passed to it, whereas
<tt>ArrayCompositor</tt> ignores everything.</p>
<p>To instantiate <tt>Composition</tt>, you pass it the compositor
you want to use:</p>
<pre>
Composition* quick = new Composition(new SimpleCompositor);
Composition* slick = new Composition(new TeXCompositor);
Composition* iconic = new Composition(new ArrayCompositor(100));
</pre>
<p><tt>Compositor</tt>'s interface is carefully designed to support all
layout algorithms that subclasses might implement.  You don't want to
have to change this interface with every new subclass, because that will
require changing existing subclasses.  In general, the Strategy and
Context interfaces determine how well the pattern achieves its intent.</p><a name="knownuses"><a>
<h3> Known Uses</h3><p>Both ET++ [WGM88] and InterViews use strategies to encapsulate
different linebreaking algorithms as we've described.</p>
<p>In the RTL System for compiler code optimization [JML92],
strategies define different register allocation schemes
(RegisterAllocator) and instruction set scheduling policies
(RISCscheduler, CISCscheduler). This provides flexibility in targeting the
optimizer for different machine architectures.</p>


<p>The ET++SwapsManager calculation engine framework computes prices for
different financial instruments [EG92]. Its key
abstractions are Instrument and YieldCurve. Different instruments are
implemented as subclasses of Instrument. YieldCurve calculates
discount factors, which determine the present value of future cash
flows. Both of these classes delegate some behavior to Strategy
objects. The framework provides a family of ConcreteStrategy classes
for generating cash flows, valuing swaps, and calculating discount
factors. You can create new calculation engines by configuring
Instrument and YieldCurve with the different ConcreteStrategy objects.
This approach supports mixing and matching existing Strategy
implementations as well as defining new ones.</p>
<p>The Booch components [BV90] use strategies as template
arguments. The Booch collection classes support three different kinds of
memory allocation strategies: managed (allocation out of a pool),
controlled (allocations/deallocations are protected by locks), and
unmanaged (the normal memory allocator). These strategies are passed as
template arguments to a collection class when it's instantiated. For
example, an UnboundedCollection that uses the unmanaged strategy is
instantiated as <tt>UnboundedCollection<MyItemType*, Unmanaged></tt>.</p>
<p>RApp is a system for integrated circuit layout [GA89, AG90].
RApp must lay out and route wires that connect subsystems on the
circuit. Routing algorithms in RApp are defined as
subclasses of an abstract Router class.  Router is a Strategy class.</p>
<p>Borland's ObjectWindows [Bor94] uses strategies in dialogs
boxes to ensure that the user enters valid data. For example, numbers might
have to be in a certain range, and a numeric entry field should accept
only digits. Validating that a string is correct can require a
table look-up.</p>
<p>ObjectWindows uses Validator objects to encapsulate validation
strategies.  Validators are examples of Strategy objects.  Data entry
fields delegate the validation strategy to an optional Validator
object. The client attaches a validator to a field if validation is
required (an example of an optional strategy).  When the dialog is
closed, the entry fields ask their validators to validate the data.
The class library provides validators for common cases, such as a
RangeValidator for numbers.  New client-specific validation strategies
can be defined easily by subclassing the Validator class.</p>
<h3> Related Patterns</h3><p>Flyweight :
Strategy objects often make good flyweights.</p>
<p>&nbsp;</p></body></html>
