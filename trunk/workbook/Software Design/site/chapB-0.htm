<html><head><title>Guide to Notation</title><link href="ff.css" rel="stylesheet" type="text/css"></head><body>
<h2>Guide to Notation</h2>
<p>We use diagrams throughout the book to illustrate important ideas.
Some diagrams are informal, like a screen shot of a dialog box or a
schematic showing a tree of objects.  But the design patterns in
particular use more formal notations to denote relationships and
interactions between classes and objects.  This appendix describes
these notations in detail.</p>
<p>We use three different diagrammatic notations:</p><ol>
<li>A <strong>class diagram</strong> depicts classes, their structure, and
the static relationships between them.</li>



<li>An <strong>object diagram</strong> depicts a particular object structure
at run-time.</li>



<li>An <strong>interaction diagram</strong> shows the flow of requests between
objects.</li></ol>
<p>Each design pattern includes at least one class diagram. The
other notations are used as needed to supplement the discussion.
The class and object diagrams are based on OMT (Object Modeling
Technique) [RBP+91, Rum94].<sup>1</sup>
The interaction diagrams
are taken from Objectory [JCJO92] and the Booch method [Boo94].  These notations are summarized
on the inside back cover of the book.</p>

<h3>
Class Diagram</h3>
<p>Figure B.1a
shows the OMT notation for abstract and concrete classes.  A class
is denoted by a box with the class name in bold type at the top.
The key operations of the class appear below the class name.  Any
instance variables appear below the operations.  Type information
is optional; we use the C++ convention, which puts the type name
before the name of the operation (to signify the return type),
instance variable, or actual parameter.  Slanted type indicates
that the class or operation is abstract.</p>


<p align=CENTER><img src="Pictures/class088.gif"><br><br>
Figure B.1:&nbsp;&nbsp;Class diagram notation</p>
<p>In some design patterns it's helpful to see where client classes
reference Participant classes.  When a pattern includes a Client
class as one of its participants (meaning the client has a
responsibility in the pattern), the Client appears as an ordinary
class.  This is true in Flyweight ,
for example.  When the pattern does not include a Client participant
(i.e., clients have no responsibilities in the pattern), but
including it nevertheless clarifies which pattern participants
interact with clients, then the Client class is shown in gray, as
shown in Figure B.1b.
An example is Proxy . A gray Client
also makes it clear that we haven't accidentally omitted the Client
from the Participants discussion.</p>



Figure B.1c shows various
relationships between classes.  The OMT notation for class inheritance
is a triangle connecting a subclass (LineShape in the figure) to its
parent class (Shape).  An object reference representing a part-of or
aggregation relationship is indicated by an arrowheaded line with a
diamond at the base.  The arrow points to the class that is aggregated
(e.g., Shape). An arrowheaded line without the diamond denotes
acquaintance (e.g., a LineShape keeps a reference to a Color object,
which other shapes may share).  A name for the reference may appear
near the base to distinguish it from other
references.<sup>2</sup>
</P>
<p>Another useful thing to show is which classes instantiate which
others.  We use a dashed arrowheaded line to indicate this, since
OMT doesn't support it.  We call this the "creates" relationship.
The arrow points to the class that's instantiated.  In
Figure B.1c,
CreationTool creates LineShape objects.</p>
<p>OMT also defines a filled circle to mean "more than one."  When
the circle appears at the head of a reference, it means multiple
objects are being referenced or aggregated.
Figure B.1c shows that Drawing aggregates
multiple objects of type Shape.</p>
<p>Finally, we've augmented OMT with pseudocode annotations to let
us sketch the implementations of operations.
Figure B.1d shows the pseudocode annotation
for the Draw operation on the Drawing class.
<h3> Object Diagram</h3>
<p>An object diagram shows instances exclusively. It provides a
snapshot of the objects in a design pattern.  The objects are named
"a<em>Something</em>", where <em>Something</em> is the class of
the object.  Our symbol for an object (modified slightly from
standard OMT) is a rounded box with a line separating the object
name from any object references.  Arrows indicate the object
referenced.
Figure B.2
shows an example.
<p align=CENTER><img src="Pictures/objec026.gif"><br><br>
Figure B.2:&nbsp;&nbsp;Object diagram notation</p>
<h3>
Interaction Diagram</h3>
<p>An interaction diagram shows the order in which requests between objects
get executed.
Figure B.3 is an
interaction diagram that shows how a shape gets added to a drawing.
<p align=CENTER><img src="Pictures/inter044.gif"><br><br>
Figure B.3:&nbsp;&nbsp;Interaction diagram notation</p>
<p>Time flows from top to bottom in an interaction diagram. A solid
vertical line indicates the lifetime of a particular object. The
naming convention for objects is the same as for object diagrams&#151;the
class name prefixed by the letter "a" (e.g., aShape).  If the object
doesn't get instantiated until after the beginning of time as recorded
in the diagram, then its vertical line appears dashed until the point
of creation.</p>
<p>A vertical rectangle shows that an object is active; that is, it is
handling a request. The operation can send requests to other objects;
these are indicated with a horizontal arrow pointing to the receiving
object. The name of the request is shown above the arrow.  A request
to create an object is shown with a dashed arrowheaded line.  A
request to the sending object itself points back to the sender.</p>

Figure B.3 
shows that the first request is from aCreationTool to
create aLineShape. Later, aLineShape is Added to aDrawing, which
prompts aDrawing to send a Refresh request to itself. Note that
aDrawing sends a Draw request to aLineShape as part of the Refresh
operation.
<hr>
<p><sup>1</sup>OMT uses the term "object diagram" to
refer to class diagrams.  We use "object diagram" exclusively to
refer to diagrams of object structures.
</p>
<p><sup>2</sup>OMT also defines <strong>associations</strong>
between classes, which appear as plain lines between class boxes.
Associations are bidirectional.  Although associations are appropriate
during analysis, we feel they're too high-level for expressing the
relationships in design patterns, simply because associations must
be mapped down to object references or pointers during design.
Object references are intrinsically directed and are therefore
better suited to the relationships that concern us.  For example,
Drawing knows about Shapes, but the Shapes don't know about the
Drawing they're in.  You can't express this relationship with
associations alone.
</p><p>&nbsp;</p></body></html>

