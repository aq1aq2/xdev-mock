<html><head>	<title>Iterator</title><link href="ff.css" rel="stylesheet" type="text/css"></head><body>
<h2>Iterator</h2>
<h3> Intent</h3><p>Provide a way to access the elements of an aggregate object
sequentially without exposing its underlying representation.</p>
<h3> Also Known As</h3><p>Cursor</p>
<h3> Motivation</h3><p>An aggregate object such as a list should give you a way to access its
elements without exposing its internal structure.  Moreover, you might
want to traverse the list in different ways, depending on what you
want to accomplish.  But you probably don't want to bloat the List
interface with operations for different traversals, even if you could
anticipate the ones you will need.  You might also need to have more than
one traversal pending on the same list.</p>
<p>The Iterator pattern lets you do all this.  The key idea in this
pattern is to take the responsibility for access and traversal out of
the list object and put it into an <strong>iterator</strong> object.  The
Iterator class defines an interface for accessing the list's elements.
An iterator object is responsible for keeping track of the current
element; that is, it knows which elements have been traversed already.</p>

<p>For example, a List class would call for a ListIterator with the
following relationship between them:</p>
<p align=CENTER><img src="Pictures/itera039.gif"></p>
<p>Before you can instantiate ListIterator, you must supply the List to
traverse.  Once you have the ListIterator instance, you can access the
list's elements sequentially.  The CurrentItem operation returns the
current element in the list, First initializes the current element to
the first element, Next advances the current element to the next
element, and IsDone tests whether we've advanced beyond the last
element&#151;that is, we're finished with the traversal.</p>
<p>Separating the traversal mechanism from the List object lets us define
iterators for different traversal policies without enumerating them in
the List interface.  For example, FilteringListIterator might provide
access only to those elements that satisfy specific filtering
constraints.</p>
<p>Notice that the iterator and the list are coupled, and the client must
know that it is a <em>list</em> that's traversed as opposed to some other
aggregate structure.  Hence the client commits to a particular
aggregate structure. It would be better if we could change the aggregate
class without changing client code.  We can do this by generalizing
the iterator concept to support <strong>polymorphic iteration</strong>.</p>
<p>As an example, let's assume that we also have a SkipList
implementation of a list. A skiplist [Pug90] is a
probabilistic data structure with characteristics similar to balanced
trees.  We want to be able to write code that works for both List and
SkipList objects.</p>
<p>We define an AbstractList class that provides a common interface
for manipulating lists.  Similarly, we need an abstract Iterator
class that defines a common iteration interface.  Then we can define
concrete Iterator subclasses for the different list implementations.
As a result, the iteration mechanism becomes independent of concrete
aggregate classes.</p>

<p align=CENTER><img src="Pictures/itera040.gif"></p>
<p>The remaining problem is how to create the iterator.  Since we want to
write code that's independent of the concrete List subclasses, we
cannot simply instantiate a specific class.  Instead, we make the list
objects responsible for creating their corresponding iterator.  This
requires an operation like CreateIterator through which clients
request an iterator object.</p>
<p>CreateIterator is an example of a factory method (see Factory Method ).  We use it here to let a client ask
a list object for the appropriate iterator.  The Factory Method
approach give rise to two class hierarchies, one for lists and another
for iterators. The CreateIterator factory method "connects" the two
hierarchies.</p>
<h3> Applicability</h3><p>Use the Iterator pattern</p><ul>
<li>to access an aggregate object's contents without exposing its internal
representation.</P>
<li>to support multiple traversals of aggregate objects.</P>
<li>to provide a uniform interface for traversing different aggregate
structures (that is, to support polymorphic iteration).</P></ul>
<h3> Structure</h3> 

<p align=CENTER><img src="Pictures/iterator.gif"></p>
<h3> Participants</h3><ul>
<li><b>Iterator</b></li>


<ul>
<li>defines an interface for accessing and traversing elements.</ul>



<li><b>ConcreteIterator</b>


<ul>
<li>implements the Iterator interface.</li>
<p><!-- extra space --></p>
<li>keeps track of the current position in the traversal of
the aggregate.</li></ul>



<li><b>Aggregate</b>


<ul>
<li>defines an interface for creating an Iterator object.</li></ul>



<li><b>ConcreteAggregate</b></li>


<ul>
<li>implements the Iterator creation interface to return an
instance of the proper ConcreteIterator.</li></ul></ul>
<h3> Collaborations</h3><ul>
<li>A ConcreteIterator keeps track of the current object in the
aggregate and can compute the succeeding object in the
traversal.</li></ul>
<h3> Consequences</h3><p>The Iterator pattern has three important consequences:</p><ol>
<li><em>It supports variations in the traversal of an aggregate.</em>
Complex aggregates may be traversed in many ways.  For example, code
generation and semantic checking involve traversing parse trees. Code
generation may traverse the parse tree inorder or preorder.
Iterators make it easy to change the traversal algorithm: Just replace
the iterator instance with a different one.  You can also define
Iterator subclasses to support new traversals.</li>

<li><em>Iterators simplify the Aggregate interface.</em>
Iterator's traversal interface obviates the need for a similar
interface in Aggregate, thereby simplifying the aggregate's interface.</li>

<li><em>More than one traversal can be pending on an aggregate.</em>
An iterator keeps track of its own traversal state.  Therefore you can
have more than one traversal in progress at once.</li></ol>
<h3> Implementation</h3><p>Iterator has many implementation variants and alternatives.  Some
important ones follow.  The trade-offs often depend on the
control structures your language provides.  Some languages 
(CLU [LG86], for example) even support this pattern directly.</p><ol>

<li><em>Who controls the iteration?</em>
A fundamental issue is deciding which party controls the iteration,
the iterator or the client that uses the iterator.  When the client
controls the iteration, the iterator is called an <strong>external
iterator</strong>, and when the iterator controls it, the iterator is an
<strong>internal iterator</strong>.<sup>2</sup>
Clients that use an
external iterator must advance the traversal and request the next
element explicitly from the iterator.  In contrast, the client hands
an internal iterator an operation to perform, and the iterator applies
that operation to every element in the aggregate.
<p>External iterators are more flexible than internal iterators.  It's
easy to compare two collections for equality with an external
iterator, for example, but it's practically impossible with internal
iterators.  Internal iterators are especially weak in a language like
C++ that does not provide anonymous functions, closures, or
continuations like Smalltalk and CLOS.  But on the other hand,
internal iterators are easier to use, because they define the iteration
logic for you.</p></li>



<li><em>Who defines the traversal algorithm?</em>
The iterator is not the only place where the traversal algorithm can
be defined.  The aggregate might define the traversal algorithm and
use the iterator to store just the state of the iteration.  We call
this kind of iterator a <strong>cursor</strong>, since it merely points to
the current position in the aggregate.  A client will invoke the Next
operation on the aggregate with the cursor as an argument, and the
Next operation will change the state of the
cursor.<sup>3</sup>
<p>If the iterator is responsible for the traversal algorithm, then it's
easy to use different iteration algorithms on the same aggregate, and
it can also be easier to reuse the same algorithm on different
aggregates.  On the other hand, the traversal algorithm might need to
access the private variables of the aggregate.  If so, putting the
traversal algorithm in the iterator violates the encapsulation of the
aggregate.</p></li>



<li><em>How robust is the iterator?</em>
It can be dangerous to modify an aggregate while you're traversing it.
If elements are added or deleted from the aggregate, you might end up
accessing an element twice or missing it completely.  A simple
solution is to copy the aggregate and traverse the copy, but that's
too expensive to do in general.
<p>A <strong>robust iterator</strong> ensures that insertions and removals
won't interfere with traversal, and it does it without copying the
aggregate.  There are many ways to implement robust iterators. Most
rely on registering the iterator with the aggregate.  On insertion or
removal, the aggregate either adjusts the internal state of iterators
it has produced, or it maintains information internally to ensure
proper traversal.</p>
<p>Kofler provides a good discussion of how robust iterators are
implemented in ET++ [Kof93].  Murray discusses the
implementation of robust iterators for the USL StandardComponents'
List class [Mur93].</p></li>



<li><em>Additional Iterator operations.</em>
The minimal interface to Iterator consists of the operations First,
Next, IsDone, and CurrentItem.<sup>4</sup>
Some
additional operations might prove useful.  For example, ordered
aggregates can have a Previous operation that positions the iterator
to the previous element.  A SkipTo operation is useful for sorted or
indexed collections.  SkipTo positions the iterator to an object
matching specific criteria.</li>



<li><em>Using polymorphic iterators in C++.</em>
Polymorphic iterators have their cost. They require the iterator
object to be allocated dynamically by a factory method.  Hence they
should be used only when there's a need for polymorphism.  Otherwise
use concrete iterators, which can be allocated on the stack.
<p>Polymorphic iterators have another drawback: the client is responsible
for deleting them.  This is error-prone, because it's easy to forget
to free a heap-allocated iterator object when you're finished with it.
That's especially likely when there are multiple exit points in an
operation.  And if an exception is triggered, the iterator object will
never be freed.</p>
<p>The Proxy  pattern provides a remedy.  We can use a
stack-allocated proxy as a stand-in for the real iterator. The proxy
deletes the iterator in its destructor.  Thus when the proxy goes out
of scope, the real iterator will get deallocated along with it.  The
proxy ensures proper cleanup, even in the face of exceptions.  This
is an application of the well-known C++ technique "resource
allocation is initialization" [ES90].  The Sample Code gives
an example.</p></li>



<li><em>Iterators may have privileged access.</em>
An iterator can be viewed as an extension of the aggregate that
created it.  The iterator and the aggregate are tightly coupled.  We
can express this close relationship in C++ by making the iterator a
<tt>friend</tt> of its aggregate.  Then you don't need to
define aggregate operations whose sole purpose is to let iterators
implement traversal efficiently.
<p>However, such privileged access can make defining new traversals
difficult, since it'll require changing the aggregate interface to add
another friend.  To avoid this problem, the Iterator class can include
<tt>protected</tt> operations for accessing important but publicly
unavailable members of the aggregate.  Iterator subclasses (and <em>only</em> Iterator subclasses) may use these protected operations to gain
privileged access to the aggregate.</p></li>



<li><em>Iterators for composites.</em>
External iterators can be difficult to implement over recursive
aggregate structures like those in the Composite 
pattern, because a position in the structure may span many levels of
nested aggregates.  Therefore an external iterator has to store a path
through the Composite to keep track of the current object.  Sometimes
it's easier just to use an internal iterator.  It can record the
current position simply by calling itself recursively, thereby storing
the path implicitly in the call stack.
<p>If the nodes in a Composite have an interface for moving from a node
to its siblings, parents, and children, then a cursor-based iterator
may offer a better alternative. The cursor only needs to keep track of
the current node; it can rely on the node interface to traverse the
Composite.</p>
<p>Composites often need to be traversed in more than one way.  Preorder,
postorder, inorder, and breadth-first traversals are common.  You can
support each kind of traversal with a different class of iterator.</p></li>



<li><em>Null iterators.</em>
A <strong>NullIterator</strong> is a degenerate iterator that's helpful for
handling boundary conditions. By definition, a NullIterator is <em>always</em> done with traversal; that is, its IsDone operation always
evaluates to true.
<p>NullIterator can make traversing tree-structured aggregates (like
Composites) easier.  At each point in the traversal, we ask the
current element for an iterator for its children.  Aggregate elements
return a concrete iterator as usual.  But leaf elements return an
instance of NullIterator.  That lets us implement traversal over the
entire structure in a uniform way.</p></li></ol><a name="samplecode"><a>
<h3> Sample Code</h3><p>We'll look at the implementation of a simple List class, which is part
of our foundation library
(Appendix&nbsp;C).
We'll
show two Iterator implementations, one for traversing the List in
front-to-back order, and another for traversing back-to-front (the
foundation library supports only the first one).  Then we show how to
use these iterators and how to avoid committing to a particular
implementation.  After that, we change the design to make sure
iterators get deleted properly.  The last example illustrates an
internal iterator and compares it to its external counterpart.</p><ol>

<li><em>List and Iterator interfaces.</em>
First let's look at the part of the List interface that's relevant to
implementing iterators. Refer to
(Appendix&nbsp;C).
for the full interface.
<pre>
template &lt;class Item>
class List {
public:
    List(long size = DEFAULT_LIST_CAPACITY);

    long Count() const;
    Item&amp; Get(long index) const;
    // ...
};
</pre>
<p>The <tt>List</tt> class provides a reasonably efficient way to
support iteration through its public interface.  It's sufficient to
implement both traversals. So there's no need to give iterators
privileged access to the underlying data structure; that is, the
iterator classes are not friends of <tt>List</tt>.  To enable
transparent use of the different traversals we define an abstract
<tt>Iterator</tt> class, which defines the iterator interface.</p>
<pre>
template &lt;class Item>
class Iterator {
public:
    virtual void First() = 0;
    virtual void Next() = 0;
    virtual bool IsDone() const = 0;
    virtual Item CurrentItem() const = 0;
protected:
    Iterator();
};
</pre></li>

<li><em>Iterator subclass implementations.</em>
<tt>ListIterator</tt> is a subclass of <tt>Iterator</tt>.
<pre>
template &lt;class Item>
class ListIterator : public Iterator&lt;Item> {
public:
    ListIterator(const List&lt;Item>* aList);
    virtual void First();
    virtual void Next();
    virtual bool IsDone() const;
    virtual Item CurrentItem() const;

private:
    const List&lt;Item>* _list;
    long _current;
};
</pre>
<p>The implementation of <tt>ListIterator</tt> is straightforward.  It
stores the <tt>List</tt> along with an index <tt>_current</tt> into
the list:</p>
<pre>
template &lt;class Item>
ListIterator&lt;Item>::ListIterator (
    const List&lt;Item>* aList
) : _list(aList), _current(0) {
}
</pre>
<p><tt>First</tt> positions the iterator to the first element:</p>
<pre>
template &lt;class Item>
void ListIterator&lt;Item>::First () {
    _current = 0;
}
</pre>
<p><tt>Next</tt> advances the current element:</p>
<pre>
template &lt;class Item>
void ListIterator&lt;Item>::Next () {
    _current++;
}
</pre>
<p><tt>IsDone</tt> checks whether the index refers to an element within
the List:</p>
<pre>
template &lt;class Item>
bool ListIterator&lt;Item>::IsDone () const {
    return _current >= _list->Count();
}
</pre>
<p>Finally, <tt>CurrentItem</tt> returns the item at the current index.
If the iteration has already terminated, then we throw an
<tt>IteratorOutOfBounds</tt> exception:</p>
<pre>
template &lt;class Item>
Item ListIterator&lt;Item>::CurrentItem () const {
    if (IsDone()) {
        throw IteratorOutOfBounds;
    }
    return _list->Get(_current);
}
</pre>
<p>The implementation of ReverseListIterator is identical, except its
<tt>First</tt> operation positions <tt>_current</tt>
to the end of the list, and <tt>Next</tt> decrements
<tt>_current</tt> toward the first item.</p></li>



<li><em>Using the iterators.</em>
Let's assume we have a <tt>List</tt> of <tt>Employee</tt> objects,
and we would like to print all the contained employees.  The
<tt>Employee</tt> class supports this with a <tt>Print</tt>
operation.  To print the list, we define a <tt>PrintEmployees</tt>
operation that takes an iterator as an argument. It uses the iterator
to traverse and print the list.
<pre>
void PrintEmployees (Iterator&lt;Employee*>&amp; i) {
    for (i.First(); !i.IsDone(); i.Next()) {
        i.CurrentItem()->Print();
    }
}
</pre>
<p>Since we have iterators for both back-to-front and front-to-back
traversals, we can reuse this operation to print the employees in both
orders.</p>
<pre>
List&lt;Employee*>* employees;
// ...
ListIterator&lt;Employee*> forward(employees);
ReverseListIterator&lt;Employee*> backward(employees);

PrintEmployees(forward);
PrintEmployees(backward);
</pre></li>
<li><em>Avoiding commitment to a specific list implementation.</em>
Let's consider how a skiplist variation of <tt>List</tt> would affect
our iteration code.  A <tt>SkipList</tt> subclass of
<tt>List</tt> must provide a <tt>SkipListIterator</tt> that
implements the <tt>Iterator</tt> interface.  Internally, the
<tt>SkipListIterator</tt> has to keep more than just an index to
do the iteration efficiently.  But since
<tt>SkipListIterator</tt> conforms to the
<tt>Iterator</tt> interface, the <tt>PrintEmployees</tt> operation
can also be used when the employees are stored in a <tt>SkipList</tt>
object.
<pre>
SkipList&lt;Employee*>* employees;
// ...

SkipListIterator&lt;Employee*> iterator(employees);
PrintEmployees(iterator);
</pre>
<p>Although this approach works, it would be better if we didn't have to commit
to a specific <tt>List</tt> implementation, namely
<tt>SkipList</tt>.  We can introduce an <tt>AbstractList</tt>
class to standardize the list interface for different list
implementations.  <tt>List</tt> and <tt>SkipList</tt> become
subclasses of <tt>AbstractList</tt>.
<p>To enable polymorphic iteration, <tt>AbstractList</tt> defines a
factory method <tt>CreateIterator</tt>, which subclasses override to
return their corresponding iterator:</p>
<pre>
template &lt;class Item>
class AbstractList {
public:
    virtual Iterator&lt;Item>* CreateIterator() const = 0;
    // ...
};
</pre>
<p>An alternative would be to define a general mixin class
<tt>Traversable</tt> that defines the interface for creating an
iterator.  Aggregate classes can mix in
<tt>Traversable</tt> to support polymorphic iteration.
<p><tt>List</tt> overrides <tt>CreateIterator</tt> to return a
<tt>ListIterator</tt> object:</p>
<pre>
template &lt;class Item>
Iterator&lt;Item>* List&lt;Item>::CreateIterator () const {
    return new ListIterator&lt;Item>(this);
}
</pre>
<p>Now we're in a position to write the code for printing
the employees independent of a concrete representation.</p>
<pre>
// we know only that we have an AbstractList
AbstractList&lt;Employee*>* employees;
// ...

Iterator&lt;Employee*>* iterator = employees->CreateIterator();
PrintEmployees(*iterator);
delete iterator;
</pre></li>
<li><em>Making sure iterators get deleted.</em>

Notice that <tt>CreateIterator</tt> returns a newly allocated
iterator object.  We're responsible for deleting it.  If we forget,
then we've created a storage leak.  To make life easier for clients,
we'll provide an <tt>IteratorPtr</tt> that acts as a proxy for an
iterator.  It takes care of cleaning up the <tt>Iterator</tt> object
when it goes out of scope.
<p><tt>IteratorPtr</tt> is always allocated on the
stack.<sup>5</sup>
C++ automatically takes care of calling
its destructor, which deletes the real iterator.
<tt>IteratorPtr</tt> overloads both
<tt>operator-></tt> and
<tt>operator*</tt> in such a way that an <tt>IteratorPtr</tt> can be
treated just like a pointer to an iterator.  The members of
<tt>IteratorPtr</tt> are all implemented inline; thus they can incur no
overhead.</p>
<pre>
template &lt;class Item>
class IteratorPtr {
public:
    IteratorPtr(Iterator&lt;Item>* i): _i(i) { }
    ~IteratorPtr() { delete _i; }

    Iterator&lt;Item>* operator->() { return _i; }
    Iterator&lt;Item>&amp; operator*() { return *_i; }
private:
    // disallow copy and assignment to avoid
    // multiple deletions of _i:

    IteratorPtr(const IteratorPtr&amp;);
    IteratorPtr&amp; operator=(const IteratorPtr&amp;);
private:
    Iterator&lt;Item>* _i;
};
</pre>
<p><tt>IteratorPtr</tt> lets us simplify our printing code:</p>
<pre>
AbstractList&lt;Employee*>* employees;
// ...

IteratorPtr&lt;Employee*> iterator(employees->CreateIterator());
PrintEmployees(*iterator);
</pre>
<li><em>An internal ListIterator.</em>
As a final example, let's look at a possible implementation of an
internal or passive <tt>ListIterator</tt> class.  Here the iterator
controls the iteration, and it applies an operation to each element.
<p>The issue in this case is how to parameterize the iterator with the
operation we want to perform on each element. C++ does not support
anonymous functions or closures that other languages provide for this
task.  There are at least two options: (1) Pass in a pointer to a
function (global or static), or (2) rely on subclassing. In the first
case, the iterator calls the operation passed to it at each point in
the iteration.  In the second case, the iterator calls an operation
that a subclass overrides to enact specific behavior.</p>
<p>Neither option is perfect.  Often you want to accumulate state during
the iteration, and functions aren't well-suited to that; we would have
to use static variables to remember the state.  An
<tt>Iterator</tt> subclass provides us with a convenient place to
store the accumulated state, like in an instance variable.  But
creating a subclass for every different traversal is more work.</p>
<p>Here's a sketch of the second option, which uses subclassing.  We call
the internal iterator a <tt>ListTraverser</tt>.</p>
<pre>
template &lt;class Item>
class ListTraverser {
public:
    ListTraverser(List&lt;Item>* aList);
    bool Traverse();
protected:
    virtual bool ProcessItem(const Item&amp;) = 0;
private:
    ListIterator&lt;Item> _iterator;
};
</pre>
<p><tt>ListTraverser</tt> takes a <tt>List</tt> instance as a parameter.
Internally it uses an external <tt>ListIterator</tt> to do the
traversal. <tt>Traverse</tt> starts the traversal and calls
<tt>ProcessItem</tt> for each item.  The internal iterator can choose to
terminate a traversal by returning <tt>false</tt> from
<tt>ProcessItem</tt>. <tt>Traverse</tt> returns whether the traversal
terminated prematurely.</p>
<pre>
template &lt;class Item>
ListTraverser&lt;Item>::ListTraverser (
    List&lt;Item>* aList
) : _iterator(aList) { }

template &lt;class Item>
bool ListTraverser&lt;Item>::Traverse () {
    bool result = false;

    for (
        _iterator.First();
        !_iterator.IsDone();
        _iterator.Next()
    ) {
        result = ProcessItem(_iterator.CurrentItem());

        if (result == false) {
            break;
        }
    }
    return result;
}
</pre>
<p>Let's use a <tt>ListTraverser</tt> to print the first 10
employees from our employee list. To do it we have to subclass
<tt>ListTraverser</tt> and override <tt>ProcessItem</tt>. We
count the number of printed employees in a <tt>_count</tt> instance
variable.</p>
<pre>
class PrintNEmployees : public ListTraverser&lt;Employee*> {
public:
    PrintNEmployees(List&lt;Employee*>* aList, int n) :
        ListTraverser&lt;Employee*>(aList),
        _total(n), _count(0) { }

protected:
    bool ProcessItem(Employee* const&amp;);
private:
    int _total;
    int _count;
};

bool PrintNEmployees::ProcessItem (Employee* const&amp; e) {
    _count++;
    e->Print();
    return _count &lt; _total;
}
</pre>
<p>Here's how <tt>PrintNEmployees</tt> prints the first 10 employees
on the list:</p>
<pre>
List&lt;Employee*>* employees;
// ...

PrintNEmployees pa(employees, 10);
pa.Traverse();
</pre>
<p>Note how the client doesn't specify the iteration loop. The entire
iteration logic can be reused. This is the primary benefit of an
internal iterator.  It's a bit more work than an external iterator,
though, because we have to define a new class.  Contrast this with
using an external iterator:</p>
<pre>
ListIterator&lt;Employee*> i(employees);
int count = 0;

for (i.First(); !i.IsDone(); i.Next()) {
    count++;
    i.CurrentItem()->Print();

    if (count >= 10) {
        break;
    }
}
</pre>
<p>Internal iterators can encapsulate different kinds of iteration. For
example, <tt>FilteringListTraverser</tt> encapsulates an
iteration that processes only items that satisfy a test:</p><pre>
template &lt;class Item>
class FilteringListTraverser {
public:
    FilteringListTraverser(List&lt;Item>* aList);
    bool Traverse();
protected:
    virtual bool ProcessItem(const Item&amp;) = 0;
    virtual bool TestItem(const Item&amp;) = 0;
private:
    ListIterator&lt;Item> _iterator;
};
</pre>
<p>This interface is the same as <tt>ListTraverser</tt>'s except for an
added <tt>TestItem</tt> member function that defines the test.
Subclasses override <tt>TestItem</tt> to specify the test.</p>
<p><tt>Traverse</tt> decides to continue the traversal based on the
outcome of the test:</p>
<pre>
template &lt;class Item>
void FilteringListTraverser&lt;Item>::Traverse () {
    bool result = false;

    for (
        _iterator.First();
        !_iterator.IsDone();
        _iterator.Next()
    ) {
        if (TestItem(_iterator.CurrentItem())) {
            result = ProcessItem(_iterator.CurrentItem());

            if (result == false) {
                break;
            }
        }
    }
    return result;
}
</pre>
<p>A variant of this class could define <tt>Traverse</tt> to return if
at least one item satisfies the test.<sup>6</sup></p></li></ol><a name="knownuses"><a>
<h3> Known Uses</h3><p>Iterators are common in object-oriented systems.  Most collection
class libraries offer iterators in one form or another.</p>
<p>Here's an example from the Booch components [Boo94], a
popular collection class library.  It provides both a fixed size
(bounded) and dynamically growing (unbounded) implementation of a
queue. The queue interface is defined by an abstract Queue class. To
support polymorphic iteration over the different queue
implementations, the queue iterator is implemented in the terms of the
abstract Queue class interface.  This variation has the advantage that
you don't need a factory method to ask the queue implementations for
their appropriate iterator.  However, it requires the interface of the
abstract Queue class to be powerful enough to implement the iterator
efficiently.</p>
<p>Iterators don't have to be defined as explicitly in Smalltalk.  The
standard collection classes (Bag, Set, Dictionary, OrderedCollection,
String, etc.) define an internal iterator method <tt>do:</tt>, which
takes a block (i.e., closure) as an argument.  Each element in the
collection is bound to the local variable in the block; then the block
is executed.  Smalltalk also includes a set of Stream classes that
support an iterator-like interface.  ReadStream is essentially an
Iterator, and it can act as an external iterator for all the
sequential collections.  There are no standard external iterators for
nonsequential collections such as Set and Dictionary.</p>
<p>Polymorphic iterators and the cleanup Proxy described earlier are
provided by the ET++ container classes [WGM88].  The Unidraw
graphical editing framework classes use cursor-based
iterators [VL90].</p>
<p>ObjectWindows 2.0 [Bor94] provides a class hierarchy of
iterators for containers.  You can iterate over different container
types in the same way.  The ObjectWindow iteration syntax relies on
overloading the postincrement operator <tt>++</tt> to advance the
iteration.</p>
<h3> Related Patterns</h3><p>Composite :
Iterators are often applied to recursive structures such as
Composites.</p>
<p>Factory Method :
Polymorphic iterators rely on factory methods to instantiate the
appropriate Iterator subclass.</p>
<p>Memento  is
often used in conjunction with the Iterator pattern.  An iterator
can use a memento to capture the state of an iteration.  The iterator
stores the memento internally.</p>
<hr>
<p><sup>2</sup>Booch refers to external and internal iterators as
<strong>active</strong> and <strong>passive</strong> iterators,
respectively [Boo94].  The
terms "active" and "passive" describe the role of the client, not
the level of activity in the iterator.
</p>
<p><sup>3</sup>Cursors are a simple example of the Memento  pattern and share many of its
implementation issues.
</p>
<p><sup>4</sup>We can make this interface
even <em>smaller</em> by merging Next, IsDone, and CurrentItem into a
single operation that advances to the next object and returns it.  If
the traversal is finished, then this operation returns a special
value (0, for instance) that marks the end of the iteration.
</p>
<p><sup>5</sup>You can ensure this at compile-time just by declaring
private <tt>new</tt> and <tt>delete</tt> operators.  An accompanying
implementation isn't needed.
</p>
<p><sup>6</sup>The <tt>Traverse</tt> operation in these examples
is a Template Method 
with primitive operations <tt>TestItem</tt> and
<tt>ProcessItem</tt>.
</p><p>&nbsp;</p></body></html>
