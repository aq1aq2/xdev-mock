<html><head><title>Foundation Classes</title><link href="ff.css" rel="stylesheet" type="text/css"></head><body>
<h2>Foundation Classes</h2>
<p>This appendix documents the foundation classes we use in the C++
sample code of several design patterns. We've intentionally kept the
classes simple and minimal.  We describe the following classes:</p><ul>
<li><tt>List</tt>, an ordered list of objects.</li>



<li><tt>Iterator</tt>,
the interface for accessing an aggregate's objects in a sequence.</li>



<li><tt>ListIterator</tt>,
an iterator for traversing a <tt>List</tt>.</li>



<li><tt>Point</tt>,
a two-dimensional point.</li>



<li><tt>Rect</tt>, an axis-aligned rectangle.</li></ul>
<p>Some newer C++ standard types may not be available on all
compilers.  In particular, if your compiler doesn't define
<tt>bool</tt>, then define it manually as</p>
<pre>
typedef int bool;
const int true = 1;
const int false = 0;
</pre>
<h3>
List</h3>
<p>The <tt>List</tt> class template provides a basic container for
storing an ordered list of objects. <tt>List</tt> stores elements by
value, which means it works for built-in types as well as class
instances. For example, <tt>List<int></tt> declares a list of
<tt>int</tt>s. But most of the patterns use <tt>List</tt> to
store pointers to objects, as in <tt>List<Glyph*></tt>.  That way
<tt>List</tt> can be used for heterogeneous lists.</p>
<p>For convenience, <tt>List</tt> also provides synonyms for stack
operations, which make code that uses <tt>List</tt> for stacks more
explicit without defining another class.</p>
<pre>
template &lt;class Item>
class List {
public:
    List(long size = DEFAULT_LIST_CAPACITY);
    List(List&amp;);
    ~List();
    List&amp; operator=(const List&amp;);

    long Count() const;
    Item&amp; Get(long index) const;
    Item&amp; First() const;
    Item&amp; Last() const;
    bool Includes(const Item&amp;) const;

    void Append(const Item&amp;);
    void Prepend(const Item&amp;);

    void Remove(const Item&amp;);
    void RemoveLast();
    void RemoveFirst();
    void RemoveAll();

    Item&amp; Top() const;
    void Push(const Item&amp;);
    Item&amp; Pop();
};
</pre>
<p>The following sections describe these operations in greater detail.</p>
<h4>Construction, Destruction, Initialization, and Assignment</h4><dl><dt><tt>List(long size)</tt></dt>
<dd>initializes the list.  The <tt>size</tt> parameter is a hint for
the initial number of elements.</dd>


<dt><tt>List(List&amp;)</tt></dt>
<dd>overrides the default copy constructor so that member data are
initialized properly.</dd>


<dt><tt>~List()</tt></dt>
<dd>frees the list's internal data structures but <em>not</em> the
elements in the list.  The class is not designed for subclassing;
therefore the destructor isn't virtual.</dd>


<dt><tt>List&amp; operator=(const List&amp;)</tt></dt>
<dd>implements the assignment operation to assign member data properly.</dd></dl><h4>Accessing</h4>
<p>These operations provide basic access to the list's elements.<dl><dt><tt>long Count() const</tt></dt>
<dd>returns the number of objects in the list.</dd>


<dt><tt>Item&amp; Get(long index) const</tt></dt>
<dd>returns the object at the given index.</dd>


<dt><tt>Item&amp; First() const</tt></dt>
<dd>returns the first object in the list.</dd>


<dt><tt>Item&amp; Last() const</tt></dt>
<dd>returns the last object in the list.</dd></dl><h4>Adding</h4><dl><dt><tt>void Append(const Item&amp;)</tt></dt>
<dd>adds the argument to the list, making it the last element.</dd>


<dt><tt>void Prepend(const Item&amp;)</tt></dt>
<dd>adds the argument to the list, making it the first element.</dd></dl>
<h4>Removing</h4><dl><dt><tt>void Remove(const Item&amp;)</tt></dt>
<dd>removes the given element from the list. This operation requires
that the type of elements in the list supports the
<tt>==</tt> operator for comparison.</dd>


<dt><tt>void RemoveFirst()</tt></dt>
<dd>removes the first element from the list.</dd>


<dt><tt>void RemoveLast()</tt></dt>
<dd>removes the last element from the list.</dd>


<dt><tt>void RemoveAll()</tt></dt>
<dd>removes all elements from the list.</dd></dl>
<h4>Stack Interface</h4><dl><dt><tt>Item&amp; Top() const</tt></dt>
<dd>returns the top element (when the List is viewed as a stack).</dd>


<dt><tt>void Push(const Item&amp;)</tt></dt>
<dd>pushes the element onto the stack.</dd>


<dt><tt>Item&amp; Pop()</tt></dt>
<dd>pops the top element from the stack.</dd></dl>
<h3>
Iterator</h3>
<p><tt>Iterator</tt> is an abstract class that defines a traversal
interface for aggregates.</p>
<pre>
template &lt;class Item>
class Iterator {
public:
    virtual void First() = 0;
    virtual void Next() = 0;
    virtual bool IsDone() const = 0;
    virtual Item CurrentItem() const = 0;
protected:
    Iterator();
};
</pre>
<p>The operations do the following:</p><dl><dt><tt>virtual void First()</tt></dt>
<dd>positions the iterator to the first object in the aggregate.</dd>


<dt><tt>virtual void Next()</tt></dt>
<dd>positions the iterator to the next object in the sequence.</dd>


<dt><tt>virtual bool IsDone() const</tt></dt>
<dd>returns <tt>true</tt> when there are no more objects in the sequence.</dd>


<dt><tt>virtual Item CurrentItem() const</tt></dt>
<dd>returns the object at the current position in the sequence.</dd></dl>
<h3>
ListIterator</h3>
<p><tt>ListIterator</tt> implements the <tt>Iterator</tt> interface
to traverse List objects.  Its constructor takes a list to traverse as
an argument.</p>
<pre>
template &lt;class Item>
class ListIterator : public Iterator&lt;Item> {
public:
    ListIterator(const List&lt;Item>* aList);

    virtual void First();
    virtual void Next();
    virtual bool IsDone() const;
    virtual Item CurrentItem() const;
};
</pre>
<h3>
Point</h3>
<p><tt>Point</tt> represents a point in a two-dimensional Cartesian
coordinate space.  <tt>Point</tt> supports some minimal vector arithmetic.
The coordinates of a <tt>Point</tt> are defined as</p>
<pre>
typedef float Coord;
</pre>
<p><tt>Point</tt>'s operations are self-explanatory.</p>
<pre>
class Point {
public:
    static const Point Zero;	

    Point(Coord x = 0.0, Coord y = 0.0);

    Coord X() const;  void X(Coord x);
    Coord Y() const;  void Y(Coord y);

    friend Point operator+(const Point&amp;, const Point&amp;);
    friend Point operator-(const Point&amp;, const Point&amp;);
    friend Point operator*(const Point&amp;, const Point&amp;);
    friend Point operator/(const Point&amp;, const Point&amp;);

    Point&amp; operator+=(const Point&amp;);
    Point&amp; operator-=(const Point&amp;);
    Point&amp; operator*=(const Point&amp;);
    Point&amp; operator/=(const Point&amp;);

    Point operator-();

    friend bool operator==(const Point&amp;, const Point&amp;);
    friend bool operator!=(const Point&amp;, const Point&amp;);

    friend ostream&amp; operator&lt;&lt;(ostream&amp;, const Point&amp;);
    friend istream&amp; operator>>(istream&amp;, Point&amp;);
};
</pre>
<p>The static member <tt>Zero</tt> represents <tt>Point(0, 0)</tt>.
<h3>
Rect</h3>
<p><tt>Rect</tt> represents an axis-aligned rectangle. A
<tt>Rect</tt> is defined by an origin point and an extent (that
is, width and height).  The <tt>Rect</tt> operations are
self-explanatory.</p>
<pre>
class Rect {
public:
    static const Rect Zero;	

    Rect(Coord x, Coord y, Coord w, Coord h);
    Rect(const Point&amp; origin, const Point&amp; extent);

    Coord Width() const;   void Width(Coord);
    Coord Height() const;  void Height(Coord);
    Coord Left() const;    void Left(Coord);
    Coord Bottom() const;  void Bottom(Coord);

    Point&amp; Origin() const; void Origin(const Point&amp;);
    Point&amp; Extent() const; void Extent(const Point&amp;);

    void MoveTo(const Point&amp;);
    void MoveBy(const Point&amp;);

    bool IsEmpty() const;
    bool Contains(const Point&amp;) const;
};
</pre>
<p>The static member <tt>Zero</tt> is equivalent to the rectangle</p>
<pre>
Rect(Point(0, 0), Point(0, 0));
</pre>
<p>&nbsp;</p></body></html>
