<html><head><title>Proxy</title><link href="ff.css" rel="stylesheet" type="text/css"></head><body>
<h2>Proxy</h2>
<h3> Intent</h3><p>Provide a surrogate or placeholder for another object to control
access to it.</p>
<h3> Also Known As</h3><p>Surrogate</p>
<h3> Motivation</h3><p>One reason for controlling access to an object is to defer the full
cost of its creation and initialization until we actually need to use
it.  Consider a document editor that can embed graphical objects in a
document. Some graphical objects, like large raster images, can be
expensive to create.  But opening a document should be fast, so we
should avoid creating all the expensive objects at once when the
document is opened.  This isn't necessary anyway, because not all of
these objects will be visible in the document at the same time.</p>
<p>These constraints would suggest creating each expensive object <em>on demand</em>,
which in this case occurs when an image becomes visible.  But what do
we put in the document in place of the image?  And how can we hide the
fact that the image is created on demand so that we don't complicate
the editor's implementation?  This optimization shouldn't impact the
rendering and formatting code, for example.</p>
<p>The solution is to use another object, an image <strong>proxy</strong>,
that acts as a stand-in for the real image. The proxy acts just like
the image and takes care of instantiating it when it's required.</p><p align=CENTER><img src="Pictures/proxy016.gif"></p>
<p>The image proxy creates the real image only when the document editor
asks it to display itself by invoking its Draw operation.  The proxy
forwards subsequent requests directly to the image.  It must therefore
keep a reference to the image after creating it.</p>
<p>Let's assume that images are stored in separate files. In this case we
can use the file name as the reference to the real object. The proxy
also stores its <strong>extent</strong>, that is, its width and height.
The extent lets the proxy respond to requests for its size from the
formatter without actually instantiating the image.</p>
<p>The following class diagram illustrates this example in more detail.</p><p align=CENTER><img src="Pictures/proxy-eg.gif"></p>
<p>The document editor accesses embedded images through the interface
defined by the abstract Graphic class. ImageProxy is a class for
images that are created on demand.  ImageProxy maintains the file name
as a reference to the image on disk.  The file name is passed as an
argument to the ImageProxy constructor.</p>
<p>ImageProxy also stores the bounding box of the image and a reference
to the real Image instance.  This reference won't be valid until the
proxy instantiates the real image.  The Draw operation makes sure the
image is instantiated before forwarding it the request.  GetExtent
forwards the request to the image only if it's instantiated; otherwise
ImageProxy returns the extent it stores.</p>
<h3> Applicability</h3><p>Proxy is applicable whenever there is a need for a more versatile
or sophisticated reference to an object than a simple pointer.  Here
are several common situations in which the Proxy pattern is
applicable:</p><ol>

<li>A <strong>remote proxy</strong> provides a local representative
for an object in a different address space. NEXTSTEP [Add94] uses the class NXProxy for
this purpose.  Coplien [Cop92]
calls this kind of proxy an "Ambassador."</li>



<li>A <strong>virtual proxy</strong>
creates expensive objects on demand.  The ImageProxy described in the
Motivation is an example of such a proxy.</li>



<li>A <strong>protection proxy</strong>
controls access to the original object. Protection proxies are useful
when objects should have different access rights.  For example,
KernelProxies in the Choices operating system [CIRM93]
provide protected access to operating system objects.</li>



<li>A <strong>smart reference</strong>
is a replacement for a bare pointer that performs additional actions
when an object is accessed.  Typical uses include</li>

<ul>
<li>counting the number of references to the real object so that it can be
freed automatically when there are no more references (also called
<strong>smart pointers</strong> [Ede92]).</li>



<li>loading a persistent object into memory when it's first referenced.</li>

<li>checking that the real object is locked before it's accessed to ensure
that no other object can change it.</li></ul></ol>
<h3> Structure</h3> <p align=CENTER><img src="Pictures/proxy017.gif"></p>
<p>Here's a possible object diagram of a proxy structure at run-time:</p><p align=CENTER><img src="Pictures/proxy015.gif"></p>
<h3> Participants</h3><ul>
<li><b>Proxy</b> (ImageProxy)</li>


<ul>
<li>maintains a reference that lets the proxy access the
real subject.  Proxy may refer to a Subject if the
RealSubject and Subject interfaces are the same.</li>
<p><!-- extra space --></p>
<li>provides an interface identical to Subject's so that a proxy can
by substituted for the real subject.</li>
<p><!-- extra space --></p>
<li>controls access to the real subject and may be responsible for
creating and deleting it.</li>
<p><!-- extra space --></p>
<li>other responsibilities depend on the kind of proxy:</li>
<p><!-- extra space --></p><ul>

   <li><em>remote proxies</em> are responsible for encoding a
    request and its arguments and for sending the encoded request to
    the real subject in a different address space.</li>
<p><!-- extra space --></p>

   <li><em>virtual proxies</em> may cache additional information
    about the real subject so that they can postpone accessing it.
    For example, the ImageProxy from the Motivation caches
    the real image's extent.</li>
<p><!-- extra space --></p>

   <li><em>protection proxies</em> check that the caller has the
    access permissions required to perform a request.</li></ul></ul>



<li><b>Subject</b> (Graphic)


<ul>
<li>defines the common interface for RealSubject and
Proxy so that a Proxy can be used anywhere a
RealSubject is expected.</li></ul>



<li><b>RealSubject</b> (Image)


<ul>
<li>defines the real object that the proxy represents.</li></ul></ul>
<h3> Collaborations</h3><ul>
<li>Proxy forwards requests to RealSubject when appropriate,
depending on the kind of proxy.</li></ul>
<h3> Consequences</h3> 

<p>The Proxy pattern introduces a level of indirection when accessing an
object.  The additional indirection has many uses, depending on the
kind of proxy:</p><ol>
<li>A remote proxy can hide the fact that an object resides in a
different address space.</li>

<li>A virtual proxy can perform optimizations such as creating an
object on demand.</li>

<li>Both protection proxies and smart references allow additional
housekeeping tasks when an object is accessed.</li></ol>
<p>There's another optimization that the Proxy pattern can hide from the
client.  It's called <strong>copy-on-write</strong>, and it's related to
creation on demand.  Copying a large and complicated object can be an
expensive operation.  If the copy is never modified, then there's no
need to incur this cost.  By using a proxy to postpone the copying
process, we ensure that we pay the price of copying the object only if
it's modified.</p>
<p>To make copy-on-write work, the subject must be reference counted.
Copying the proxy will do nothing more than increment this reference
count.  Only when the client requests an operation that modifies the
subject does the proxy actually copy it.  In that case the proxy must
also decrement the subject's reference count.  When the reference
count goes to zero, the subject gets deleted.</p>
<p>Copy-on-write can reduce the cost of copying heavyweight subjects
significantly.</p>
<h3> Implementation</h3><p>The Proxy pattern can exploit the following language features:</p><ol>
<li><em>Overloading the member access operator in C++.</em>
C++ supports overloading <tt>operator-></tt>, the member access
operator.  Overloading this operator lets you perform additional work
whenever an object is dereferenced. This can be helpful for
implementing some kinds of proxy; the proxy behaves just like a
pointer.
<p>The following example illustrates how to use this technique to
implement a virtual proxy called <tt>ImagePtr</tt>.</p>
<pre>
class Image;
extern Image* LoadAnImageFile(const char*);
    // external function

class ImagePtr {
public:
    ImagePtr(const char* imageFile);
    virtual ~ImagePtr();

    virtual Image* operator->();
    virtual Image&amp; operator*();
private:
    Image* LoadImage();
private:
    Image* _image;
    const char* _imageFile;
};

ImagePtr::ImagePtr (const char* theImageFile) {
    _imageFile = theImageFile;
    _image = 0;
}

Image* ImagePtr::LoadImage () {
    if (_image == 0) {
        _image = LoadAnImageFile(_imageFile);
    }
    return _image;
}
</pre>
<p>The overloaded <tt>-></tt> and <tt>*</tt> operators use
<tt>LoadImage</tt> to return <tt>_image</tt> to callers (loading it
if necessary).</p>
<pre>
Image* ImagePtr::operator-> () {
    return LoadImage();
}

Image&amp; ImagePtr::operator* () {
    return *LoadImage();
}
</pre>
<p>This approach lets you call <tt>Image</tt> operations through
<tt>ImagePtr</tt> objects without going to the trouble of making the
operations part of the
<tt>ImagePtr</tt> interface:</p>
<pre>
ImagePtr image = ImagePtr("anImageFileName");
image->Draw(Point(50, 100));  
    // (image.operator->())->Draw(Point(50, 100))
</pre>
<p>Notice how the <tt>image</tt> proxy acts like a pointer, but it's not
declared to be a pointer to an <tt>Image</tt>.  That means you can't
use it exactly like a real pointer to an
<tt>Image</tt>.  Hence clients must treat <tt>Image</tt> and
<tt>ImagePtr</tt> objects differently in this approach.</p>
<p>Overloading the member access operator isn't a good solution for every
kind of proxy.  Some proxies need to know precisely <em>which</em>
operation is called, and overloading the member access operator
doesn't work in those cases.</p>
<p>Consider the virtual proxy example in the Motivation.  The image
should be loaded at a specific time&#151;namely when the Draw operation
is called&#151;and not whenever the image is referenced.  Overloading the
access operator doesn't allow this distinction.  In that case we must
manually implement each proxy operation that forwards the request to
the subject.</p>
<p>These operations are usually very similar to each other, as the Sample
Code demonstrates.  Typically all operations verify that the request
is legal, that the original object exists, etc., before forwarding the
request to the subject.  It's tedious to write this code again and
again.  So it's common to use a preprocessor to generate it
automatically.</p></li>
<li><em>Using <tt>doesNotUnderstand</tt> in Smalltalk.</em>
Smalltalk provides a hook that you can use to
support automatic forwarding of requests.  Smalltalk calls
<tt>doesNotUnderstand: aMessage</tt> when a client sends a message to
a receiver that has no corresponding method.  The Proxy class can
redefine <tt>doesNotUnderstand</tt> so that the message is forwarded
to its subject.
<p>To ensure that a request is forwarded to the subject and not just
absorbed by the proxy silently, you can define a Proxy class that
doesn't understand <em>any</em> messages.  Smalltalk lets you do this by
defining Proxy as a class with no
superclass.<sup>6</sup></p>
<p>The main disadvantage of <tt>doesNotUnderstand:</tt> is that most
Smalltalk systems have a few special messages that are handled
directly by the virtual machine, and these do not cause the usual
method look-up.  The only one that's usually implemented in Object (and
so can affect proxies) is the identity operation <tt>==</tt>.</p>
<p>If you're going to use <tt>doesNotUnderstand:</tt> to implement
Proxy, then you must design around this problem.  You can't expect
identity on proxies to mean identity on their real subjects.  An added
disadvantage is that <tt>doesNotUnderstand:</tt> was developed for
error handling, not for building proxies, and so it's generally not
very fast.</p></li>

<li><em>Proxy doesn't always have to know the type of real subject.</em>
If a Proxy class can deal with its subject solely through an abstract
interface, then there's no need to make a Proxy class for each
RealSubject class; the proxy can deal with all RealSubject classes
uniformly.  But if Proxies are going to instantiate RealSubjects (such
as in a virtual proxy), then they have to know the concrete class.</li></ol>
<p>Another implementation issue involves how to refer to the subject
before it's instantiated.  Some proxies have to refer to their subject
whether it's on disk or in memory.  That means they must use some form
of address space-independent object identifiers.  We used a file name
for this purpose in the Motivation.</p>
<h3> Sample Code</h3><p>The following code implements two kinds of proxy: the virtual proxy
described in the Motivation section, and a proxy implemented with
<tt>doesNotUnderstand:</tt>.<sup>7</sup></p><ol>
<li><em>A virtual proxy.</em>
The <tt>Graphic</tt> class defines the interface for graphical
objects:
<pre>
class Graphic {
public:
    virtual ~Graphic();

    virtual void Draw(const Point&amp; at) = 0;
    virtual void HandleMouse(Event&amp; event) = 0;

    virtual const Point&amp; GetExtent() = 0;

    virtual void Load(istream&amp; from) = 0;
    virtual void Save(ostream&amp; to) = 0;
protected:
    Graphic();
};
</pre>
<p>The <tt>Image</tt> class implements the <tt>Graphic</tt> interface
to display image files. <tt>Image</tt> overrides
<tt>HandleMouse</tt> to let users resize the image interactively.</p>
<pre>
class Image : public Graphic {
public:
    Image(const char* file);  // loads image from a file
    virtual ~Image();

    virtual void Draw(const Point&amp; at);
    virtual void HandleMouse(Event&amp; event);

    virtual const Point&amp; GetExtent();

    virtual void Load(istream&amp; from);
    virtual void Save(ostream&amp; to);
private:
    // ...
};
</pre>
<p><tt>ImageProxy</tt> has the same interface as <tt>Image</tt>:</p>
<pre>
class ImageProxy : public Graphic {
public:
    ImageProxy(const char* imageFile);
    virtual ~ImageProxy();

    virtual void Draw(const Point&amp; at);
    virtual void HandleMouse(Event&amp; event);

    virtual const Point&amp; GetExtent();

    virtual void Load(istream&amp; from);
    virtual void Save(ostream&amp; to);
protected:
    Image* GetImage();
private:
    Image* _image;
    Point _extent;
    char* _fileName;
};
</pre>
<p>The constructor saves a local copy of the name of the file that stores
the image, and it initializes <tt>_extent</tt> and
<tt>_image</tt>:</p>
<pre>
ImageProxy::ImageProxy (const char* fileName)  {
    _fileName = strdup(fileName);
    _extent = Point::Zero;  // don't know extent yet
    _image = 0;
}

Image* ImageProxy::GetImage() {
    if (_image == 0) {
        _image = new Image(_fileName);
    }
    return _image;
}
</pre>
<p>The implementation of <tt>GetExtent</tt> returns the cached extent if
possible; otherwise the image is loaded from the file. <tt>Draw</tt>
loads the image, and <tt>HandleMouse</tt> forwards the event to the
real image.</p>
<pre>
const Point&amp; ImageProxy::GetExtent () {
    if (_extent == Point::Zero) {
        _extent = GetImage()->GetExtent();
    }
    return _extent;
}

void ImageProxy::Draw (const Point&amp; at) {
    GetImage()->Draw(at);
}

void ImageProxy::HandleMouse (Event&amp; event) {
    GetImage()->HandleMouse(event);
}
</pre>
<p>The <tt>Save</tt> operation saves the cached image extent and the
image file name to a stream. <tt>Load</tt> retrieves this information
and initializes the corresponding members.</p>
<pre>
void ImageProxy::Save (ostream&amp; to) {
    to &lt;&lt; _extent &lt;&lt; _fileName;
}

void ImageProxy::Load (istream&amp; from) {
    from >> _extent >> _fileName;
}
</pre>
<p>Finally, suppose we have a class <tt>TextDocument</tt> that can contain
<tt>Graphic</tt> objects:</p>
<pre>
class TextDocument {
public:
    TextDocument();

    void Insert(Graphic*);
    // ...
};
</pre>
<p>We can insert an <tt>ImageProxy</tt> into a text document like this:</p>
<pre>
TextDocument* text = new TextDocument;
// ...
text->Insert(new ImageProxy("anImageFileName"));
</pre></li>
<li><em>Proxies that use <tt>doesNotUnderstand</tt>.</em> You
can make generic proxies in Smalltalk by defining classes whose
superclass is nil<sup>8</sup>
and defining the <tt>doesNotUnderstand:</tt> method to handle
messages.
<p>The following method assumes the proxy has a <tt>realSubject</tt>
method that returns its real subject.  In the case of ImageProxy, this
method would check to see if the the Image had been created, create it
if necessary, and finally return it.  It uses
<tt>perform:withArguments:</tt> to perform the message being trapped
on the real subject.</p>
<pre>
doesNotUnderstand: aMessage
    ^ self realSubject
        perform: aMessage selector
        withArguments: aMessage arguments
</pre>

<p>The argument to <tt>doesNotUnderstand:</tt> is an instance of
<tt>Message</tt> that represents the message not understood by the
proxy.  So the proxy responds to all messages by making sure that the
real subject exists before forwarding the message to it.</p>
<p>One of the advantages of <tt>doesNotUnderstand:</tt> is it can
perform arbitrary processing.  For example, we could produce a
protection proxy by specifying a set <tt>legalMessages</tt> of
messages to accept and then giving the proxy the following method:</p>
<pre>
doesNotUnderstand: aMessage
    ^ (legalMessages includes: aMessage selector)
        ifTrue: [self realSubject
            perform: aMessage selector
            withArguments: aMessage arguments]
        ifFalse: [self error: 'Illegal operator']
</pre>

<p>This method checks to see that a message is legal before forwarding it
to the real subject. If it isn't legal, then it will send
<tt>error:</tt> to the proxy,
which will result in an infinite loop of errors unless the proxy
defines <tt>error:</tt>.  Consequently, the definition of
<tt>error:</tt> should be copied from class Object along with
any methods it uses.</p></li></ol>
<h3> Known Uses</h3><p>The virtual proxy example in the Motivation section is from the ET++
text building block classes.</p>
<p>NEXTSTEP [Add94] uses proxies (instances of class NXProxy)
as local representatives for objects that may be distributed.  A
server creates proxies for remote objects when clients request them.
On receiving a message, the proxy encodes it along with its arguments
and then forwards the encoded message to the remote subject.
Similarly, the subject encodes any return results and sends them back
to the NXProxy object.</p>
<p>McCullough [McC87] discusses using proxies in
Smalltalk to access remote objects. Pascoe [Pas86]
describes how to provide side-effects on method calls and access
control with "Encapsulators."</p>
<h3> Related Patterns</h3><p>Adapter : An
adapter provides a different interface to the object it adapts. In
contrast, a proxy provides the same interface as its subject.
However, a proxy used for access protection might refuse to perform
an operation that the subject will perform, so its interface may
be effectively a subset of the subject's.</p>
<p>Decorator :
Although decorators can have similar implementations as proxies,
decorators have a different purpose. A decorator adds one or more
responsibilities to an object, whereas a proxy controls access to
an object.</p>
<p>Proxies vary in the degree to which they are implemented like a
decorator.  A protection proxy might be implemented exactly like a
decorator.  On the other hand, a remote proxy will not contain a
direct reference to its real subject but only an indirect reference,
such as "host ID and local address on host."  A virtual proxy will
start off with an indirect reference such as a file name but will
eventually obtain and use a direct reference.</p>
<hr>
<p><sup>6</sup>The implementation of distributed objects in NEXTSTEP [Add94]
(specifically, the class NXProxy) uses this technique.  The
implementation redefines <tt>forward</tt>, the equivalent hook
in NEXTSTEP.
</p>
<p><sup>7</sup>Iterator 
describes another kind of proxy on
.
</p>
<p><sup>8</sup>Almost all classes ultimately have Object
as their superclass.  Hence this is the same as saying "defining a
class that doesn't have Object as its superclass."
</p><p>&nbsp;</p></body></html>

