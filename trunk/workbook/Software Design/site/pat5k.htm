<html><head><title>Visitor</title><link href="ff.css" rel="stylesheet" type="text/css"></head><body>
<h2>Visitor</h2>
<h3> Intent</h3><p>Represent an operation to be performed on the elements of an object
structure.  Visitor lets you define a new operation without changing the
classes of the elements on which it operates.</p>
<h3> Motivation</h3><p>Consider a compiler that represents programs as abstract syntax trees.
It will need to perform operations on abstract syntax trees for "static
semantic" analyses like checking that all variables are defined. It
will also need to generate code. So it might define operations for
type-checking, code optimization, flow analysis, checking for variables
being assigned values before they're used, and so on. Moreover, we could
use the abstract syntax trees for pretty-printing, program
restructuring, code instrumentation, and computing various metrics of a
program.</p>
<p>Most of these operations will need to treat nodes that represent
assignment statements differently from nodes that represent variables or
arithmetic expressions. Hence there will be one class for assignment
statements, another for variable accesses, another for arithmetic
expressions, and so on. The set of node classes depends on the language
being compiled, of course, but it doesn't change much for a given
language.</p>
<p align=CENTER><img src="Pictures/visit006.gif"></p>
<p>This diagram shows part of the Node class hierarchy.  The problem here
is that distributing all these operations across the various node
classes leads to a system that's hard to understand, maintain, and
change. It will be confusing to have type-checking code mixed with
pretty-printing code or flow analysis code. Moreover, adding a new
operation usually requires recompiling all of these classes. It would be
better if each new operation could be added separately, and the node
classes were independent of the operations that apply to them.</p>
<p>We can have both by packaging related operations from each class in a
separate object, called a <strong>visitor</strong>, and passing it to
elements of the abstract syntax tree as it's traversed. When an element
"accepts" the visitor, it sends a request to the visitor that encodes
the element's class. It also includes the element as an argument. The
visitor will then execute the operation for that element&#151;the
operation that used to be in the class of the element.</p>
<p>For example, a compiler that didn't use visitors might type-check a
procedure by calling the TypeCheck operation on its abstract syntax
tree. Each of the nodes would implement TypeCheck by calling TypeCheck
on its components (see the preceding class diagram). If the compiler
type-checked a procedure using visitors, then it would create a
TypeCheckingVisitor object and call the Accept operation on the
abstract syntax tree with that object as an argument. Each of the
nodes would implement Accept by calling back on the visitor: an
assignment node calls VisitAssignment operation on the visitor, while
a variable reference calls VisitVariableReference. What used to be the
TypeCheck operation in class AssignmentNode is now the VisitAssignment
operation on TypeCheckingVisitor.</p>
<p>To make visitors work for more than just type-checking, we need an
abstract parent class NodeVisitor for all visitors of an abstract syntax
tree. NodeVisitor must declare an operation for each node class. An
application that needs to compute program metrics will define new
subclasses of NodeVisitor and will no longer need to add
application-specific code to the node classes. The Visitor pattern
encapsulates the operations for each compilation phase in a Visitor
associated with that phase.</p>
<p align=CENTER><img src="Pictures/visit113.gif"></p>
<p align=CENTER><img src="Pictures/visit112.gif"></p>
<p>With the Visitor pattern, you define two class hierarchies: one for the
elements being operated on (the Node hierarchy) and one for the visitors
that define operations on the elements (the NodeVisitor hierarchy). You
create a new operation by adding a new subclass to the visitor class
hierarchy. As long as the grammar that the compiler accepts doesn't
change (that is, we don't have to add new Node subclasses), we can add
new functionality simply by defining new NodeVisitor subclasses.</p>
<h3> Applicability</h3><p>Use the Visitor pattern when</p><ul>
<li>an object structure contains many classes of objects with differing
interfaces, and you want to perform operations on these objects that
depend on their concrete classes.</li>

<li>many distinct and unrelated operations need to be performed on objects
in an object structure, and you want to avoid "polluting" their
classes with these operations. Visitor lets you keep related operations
together by defining them in one class. When the object structure is
shared by many applications, use Visitor to put operations in just those
applications that need them.</li>

<li>the classes defining the object structure rarely change, but you often
want to define new operations over the structure. Changing the object
structure classes requires redefining the interface to all visitors,
which is potentially costly. If the object structure classes change
often, then it's probably better to define the operations in those
classes.</li></ul>
<h3> Structure</h3> <p align=CENTER><img src="Pictures/visitor.gif"></p>
<h3> Participants</h3><ul>
<li><b>Visitor</b> (NodeVisitor)</li>


<ul>
<li>declares a Visit operation for each class of ConcreteElement
in the object structure.  The operation's name and
signature identifies the class that sends the Visit
request to the visitor. That lets the visitor determine the
concrete class of the element being visited.  Then the visitor
can access the element directly through its particular interface.</li></ul>



<li><b>ConcreteVisitor</b> (TypeCheckingVisitor)</li>


<ul>
<li>implements each operation declared by Visitor. Each operation
implements a fragment of the algorithm defined for the corresponding
class of object in the structure.  ConcreteVisitor provides the
context for the algorithm and stores its local state. This state often
accumulates results during the traversal of the structure.</li></ul>



<li><b>Element</b> (Node)</li>


<ul>
<li>defines an Accept operation that takes a visitor as an argument.</li></ul>



<li><b>ConcreteElement</b> (AssignmentNode,VariableRefNode)</li>


<ul>
<li>implements an Accept operation that takes a visitor as an
argument.</li></ul>



<li><b>ObjectStructure</b> (Program)</li>


<ul>
<li>can enumerate its elements.</li>
<p><!-- extra space --></p>
<li>may provide a high-level interface to allow the visitor
to visit its elements.</li>
<p><!-- extra space --></p>
<li>may either be a composite (see
Composite )
or a collection such as a list or a set.</li></ul></ul>
<h3> Collaborations</h3><ul>
<li>A client that uses the Visitor pattern must create a ConcreteVisitor
object and then traverse the object structure, visiting each element
with the visitor.</li>

<li>When an element is visited, it calls the Visitor operation that
corresponds to its class.  The element supplies itself as an argument
to this operation to let the visitor access its state, if necessary.
<p>The following interaction diagram illustrates the collaborations
between an object structure, a visitor, and two elements:</p><p align=CENTER><img src="Pictures/visit003.gif"></p></li></ul>
<h3> Consequences</h3><p>Some of the benefits and liabilities of the Visitor pattern are as follows:</p><ol>
<li><em>Visitor makes adding new operations easy.</em>
Visitors make it easy to add operations that depend on the components of
complex objects. You can define a new operation over an object structure
simply by adding a new visitor. In contrast, if you spread functionality
over many classes, then you must change each class to define a new
operation.</li>

<li><em>A visitor gathers related operations and separates unrelated ones.</em>
Related behavior isn't spread over the classes defining the object
structure; it's localized in a visitor. Unrelated sets of behavior are
partitioned in their own visitor subclasses. That simplifies both the
classes defining the elements and the algorithms defined in the
visitors. Any algorithm-specific data structures can be hidden in the
visitor.</li>

<li><em>Adding new ConcreteElement classes is hard.</em>
The Visitor pattern makes it hard to add new subclasses of Element. Each
new ConcreteElement gives rise to a new abstract operation on Visitor and
a corresponding implementation in every ConcreteVisitor class. Sometimes a
default implementation can be provided in Visitor that can be inherited
by most of the ConcreteVisitors, but this is the exception rather than
the rule.
<p>So the key consideration in applying the Visitor pattern is whether you
are mostly likely to change the algorithm applied over an object
structure or the classes of objects that make up the structure. The
Visitor class hierarchy can be difficult to maintain when new
ConcreteElement classes are added frequently. In such cases, it's
probably easier just to define operations on the classes that make up
the structure. If the Element class hierarchy is stable, but you are
continually adding operations or changing algorithms, then the Visitor
pattern will help you manage the changes.</p></li>
<li><em>Visiting across class hierarchies.</em>
An iterator (see Iterator ) can visit the objects in a
structure as it traverses them by calling their operations. But an iterator
can't work across object structures with different types of elements. For
example, the Iterator interface defined on
 can access only objects of type <tt>Item</tt>:
<pre>
template &lt;class Item>
class Iterator {
    // ...
    Item CurrentItem() const;
};
</pre>
<p>This implies that all elements the iterator can visit have a common parent
class <tt>Item</tt>.</p>
<p>Visitor does not have this restriction.  It can visit objects that
don't have a common parent class. You can add any type of object to a
Visitor interface.  For example, in</p>
<pre>
class Visitor {
public:
    // ...
    void VisitMyType(MyType*);
    void VisitYourType(YourType*);
};
</pre>
<p><tt>MyType</tt> and <tt>YourType</tt> do not have to be related through
inheritance at all.</p></li>



<li><em>Accumulating state.</em>
Visitors can accumulate state as they visit each element in the object
structure.  Without a visitor, this state would be passed as extra
arguments to the operations that perform the traversal, or they
might appear as global variables.</li>



<li><em>Breaking encapsulation.</em>
Visitor's approach assumes that the ConcreteElement interface is powerful
enough to let visitors do their job.  As a result, the pattern often
forces you to provide public operations that access an element's
internal state, which may compromise its encapsulation.</li></ol>
<h3> Implementation</h3><p>Each object structure will have an associated Visitor class.  This
abstract visitor class declares a VisitConcreteElement operation for
each class of ConcreteElement defining the object structure.  Each
Visit operation on the Visitor declares its argument to be a
particular ConcreteElement, allowing the Visitor to access the
interface of the ConcreteElement directly.  ConcreteVisitor classes
override each Visit operation to implement visitor-specific behavior
for the corresponding ConcreteElement class.</p>
<p>The Visitor class would be declared like this in C++:</p>
<pre>
class Visitor {
public:
    virtual void VisitElementA(ElementA*);
    virtual void VisitElementB(ElementB*);

    // and so on for other concrete elements
protected:
    Visitor();
};
</pre>
<p>Each class of ConcreteElement implements an <tt>Accept</tt> operation
that calls the matching <tt>Visit...</tt> operation on the visitor
for that ConcreteElement.  Thus the operation that ends up getting
called depends on both the class of the element and the class of the
visitor.<sup>10</sup></p>
<p>The concrete elements are declared as</p>
<pre>
class Element {
public:
    virtual ~Element();
    virtual void Accept(Visitor&amp;) = 0;
protected:
    Element();
};

class ElementA : public Element {
public:
    ElementA();
    virtual void Accept(Visitor&amp; v) { v.VisitElementA(this); }
};

class ElementB : public Element {
public:
    ElementB();
    virtual void Accept(Visitor&amp; v) { v.VisitElementB(this); }
};
</pre>
<p>A <tt>CompositeElement</tt> class might implement <tt>Accept</tt>
like this:</p>
<pre>
class CompositeElement : public Element {
public:
    virtual void Accept(Visitor&amp;);
private:
    List&lt;Element*>* _children;
};

void CompositeElement::Accept (Visitor&amp; v) {
    ListIterator&lt;Element*> i(_children);

    for (i.First(); !i.IsDone(); i.Next()) {
        i.CurrentItem()->Accept(v);
    }
    v.VisitCompositeElement(this);
}
</pre>
<p>Here are two other implementation issues that arise when you apply the
Visitor pattern:</p><ol>

<li><em>Double dispatch.</em>
Effectively, the Visitor pattern lets you add operations to classes
without changing them.  Visitor achieves this by using a technique
called <strong>double-dispatch</strong>.  It's a well-known technique.  In
fact, some programming languages support it directly (CLOS, for
example).  Languages like C++ and Smalltalk support
<strong>single-dispatch</strong>.
<p>In single-dispatch languages, two criteria determine which operation
will fulfill a request: the name of the request and the type of
receiver. For example, the operation that a GenerateCode request will
call depends on the type of node object you ask. In C++, calling
<tt>GenerateCode</tt> on an instance of <tt>VariableRefNode</tt> will
call <tt>VariableRefNode::GenerateCode</tt> (which generates code for a
variable reference). Calling <tt>GenerateCode</tt> on an
<tt>AssignmentNode</tt> will call
<tt>AssignmentNode::GenerateCode</tt> (which will generate code for an
assignment). The operation that gets executed depends both on the kind
of request and the type of the receiver.</p>
<p>"Double-dispatch" simply means the operation that gets executed
depends on the kind of request and the types of <em>two</em> receivers.
<tt>Accept</tt> is a double-dispatch operation.  Its meaning depends
on two types: the Visitor's and the Element's.  Double-dispatching
lets visitors request different operations on each class of
element.<sup>11</sup></p>
<p>This is the key to the Visitor pattern: The operation that gets
executed depends on both the type of Visitor and the type of Element
it visits.  Instead of binding operations statically into the Element
interface, you can consolidate the operations in a Visitor and use
<tt>Accept</tt> to do the binding at run-time.  Extending the Element
interface amounts to defining one new Visitor subclass rather than many new
Element subclasses.</p></li>
<li><em>Who is responsible for traversing the object structure?</em>
A visitor must visit each element of the object structure. The question
is, how does it get there? We can put responsibility for traversal in
any of three places: in the object structure, in the visitor, or in a
separate iterator object (see Iterator ).
<p>Often the object structure is responsible for iteration. A collection
will simply iterate over its elements, calling the Accept operation on
each. A composite will commonly traverse itself by having each Accept
operation traverse the element's children and call Accept on each of
them recursively.</p>
<p>Another solution is to use an iterator to visit the elements. In C++,
you could use either an internal or external iterator, depending on what
is available and what is most efficient. In Smalltalk, you usually use
an internal iterator using <tt>do:</tt> and a block. Since internal
iterators are implemented by the object structure, using an internal
iterator is a lot like making the object structure responsible for
iteration. The main difference is that an internal iterator will not
cause double-dispatching&#151;it will call an operation on the <em>visitor</em> with an <em>element</em> as an argument as opposed to calling an
operation on the <em>element</em> with the <em>visitor</em> as an argument.
But it's easy to use the Visitor pattern with an internal iterator if
the operation on the visitor simply calls the operation on the element
without recursing.</p>
<p>You could even put the traversal algorithm in the visitor, although you'll
end up duplicating the traversal code in each ConcreteVisitor for each
aggregate ConcreteElement. The main reason to put the traversal strategy
in the visitor is to implement a particularly complex traversal, one
that depends on the results of the operations on the object structure.
We'll give an example of such a case in the Sample Code.</p></li></ol><a name="samplecode"><a>
<h3> Sample Code</h3><p>Because visitors are usually associated with composites, we'll use the
<tt>Equipment</tt> classes defined in the Sample Code of
Composite  to illustrate the Visitor pattern.  We
will use Visitor to define operations for computing the
inventory of materials and the total cost for a piece of equipment.
The <tt>Equipment</tt> classes are so simple that using Visitor
isn't really necessary, but they make it easy to see what's
involved in implementing the pattern.</p>
<p>Here again is the <tt>Equipment</tt> class from
Composite .  We've augmented it with an
<tt>Accept</tt> operation to let it work with a visitor.</p>
<pre>
class Equipment {
public:
    virtual ~Equipment();

    const char* Name() { return _name; }

    virtual Watt Power();
    virtual Currency NetPrice();
    virtual Currency DiscountPrice();

    virtual void Accept(EquipmentVisitor&amp;);
protected:
    Equipment(const char*);
private:
    const char* _name;
};
</pre>
<p>The <tt>Equipment</tt> operations return the attributes of a piece of
equipment, such as its power consumption and cost.  Subclasses redefine
these operations appropriately for specific types of equipment (e.g.,
a chassis, drives, and planar boards).</p>
<p>The abstract class for all visitors of equipment has a virtual
function for each subclass of equipment, as shown next.  All of the
virtual functions do nothing by default.</p>
<pre>
class EquipmentVisitor {
public:
    virtual ~EquipmentVisitor();

    virtual void VisitFloppyDisk(FloppyDisk*);
    virtual void VisitCard(Card*);
    virtual void VisitChassis(Chassis*);
    virtual void VisitBus(Bus*);

    // and so on for other concrete subclasses of Equipment
protected:
    EquipmentVisitor();
};
</pre>
<p><tt>Equipment</tt> subclasses define <tt>Accept</tt> in
basically the same way: It calls the
<tt>EquipmentVisitor</tt> operation that corresponds to the class
that received the <tt>Accept</tt> request, like this:</p>
<pre>
void FloppyDisk::Accept (EquipmentVisitor&amp; visitor) {
   visitor.VisitFloppyDisk(this);
}
</pre>
<p>Equipment that contains other equipment (in particular, subclasses of
<tt>CompositeEquipment</tt> in the Composite pattern) implements
<tt>Accept</tt> by iterating over its children and calling
<tt>Accept</tt> on each of them. Then it calls the
<tt>Visit</tt> operation as usual.
For example, <tt>Chassis::Accept</tt> could traverse
all the parts in the chassis as follows:</p>
<pre>
void Chassis::Accept (EquipmentVisitor&amp; visitor) {
    for (
        ListIterator<Equipment*> i(_parts);
        !i.IsDone();
        i.Next()
    ) {
        i.CurrentItem()->Accept(visitor);
    }
    visitor.VisitChassis(this);
}
</pre>
<p>Subclasses of <tt>EquipmentVisitor</tt> define particular algorithms
over the equipment structure. The <tt>PricingVisitor</tt> computes the
cost of the equipment structure. It computes the net price of all simple
equipment (e.g., floppies) and the discount price of all composite
equipment (e.g., chassis and buses).</p>
<pre>
class PricingVisitor : public EquipmentVisitor {
public:
    PricingVisitor();

    Currency&amp; GetTotalPrice();

    virtual void VisitFloppyDisk(FloppyDisk*);
    virtual void VisitCard(Card*);
    virtual void VisitChassis(Chassis*);
    virtual void VisitBus(Bus*);
    // ...
private:
    Currency _total;
};

void PricingVisitor::VisitFloppyDisk (FloppyDisk* e) {
    _total += e->NetPrice();
}

void PricingVisitor::VisitChassis (Chassis* e) {
    _total += e->DiscountPrice();
}
</pre>
<p><tt>PricingVisitor</tt> will compute the total cost of all nodes in the
equipment structure. Note that <tt>PricingVisitor</tt> chooses the
appropriate pricing policy for a class of equipment by dispatching to
the corresponding member function. What's more, we can change the
pricing policy of an equipment structure just by changing the
<tt>PricingVisitor</tt> class.</p>
<p>We can define a visitor for computing inventory like this:
<pre>
class InventoryVisitor : public EquipmentVisitor {
public:
    InventoryVisitor();

    Inventory&amp; GetInventory();

    virtual void VisitFloppyDisk(FloppyDisk*);
    virtual void VisitCard(Card*);
    virtual void VisitChassis(Chassis*);
    virtual void VisitBus(Bus*);
    // ...

private:
    Inventory _inventory;
};
</pre>
<p>The <tt>InventoryVisitor</tt> accumulates the totals for each type of
equipment in the object structure. <tt>InventoryVisitor</tt> uses an
<tt>Inventory</tt> class that defines an interface for adding equipment
(which we won't bother defining here).</p>
<pre>
void InventoryVisitor::VisitFloppyDisk (FloppyDisk* e) {
    _inventory.Accumulate(e);
}

void InventoryVisitor::VisitChassis (Chassis* e) {
    _inventory.Accumulate(e);
}
</pre>
<p>Here's how we can use an <tt>InventoryVisitor</tt> on an
equipment structure:</p>
<pre>
Equipment* component;
InventoryVisitor visitor;

component->Accept(visitor);
cout &lt;&lt; "Inventory "
     &lt;&lt; component->Name()
     &lt;&lt; visitor.GetInventory();
</pre>
<p>Now we'll show how to implement the Smalltalk example from the Interpreter
pattern (see
) with the
Visitor pattern. Like the previous example, this one is so small that
Visitor probably won't buy us much, but it provides a good illustration of
how to use the pattern. Further, it illustrates a situation in which
iteration is the visitor's responsibility.</p>
<p>The object structure (regular expressions) is made of four classes,
and all of them have an <tt>accept:</tt> method that takes the
visitor as an argument.  In class <tt>SequenceExpression</tt>, the
<tt>accept:</tt> method is</p>
<pre>
accept: aVisitor
     ^ aVisitor visitSequence: self
</pre>


<p>In class <tt>RepeatExpression</tt>, the <tt>accept:</tt> method
sends the <tt>visitRepeat:</tt> message.
In class <tt>AlternationExpression</tt>, it sends the
<tt>visitAlternation:</tt> message.
In class <tt>LiteralExpression</tt>, it sends the
<tt>visitLiteral:</tt> message.</p>
<p>The four classes also must have accessing functions that the visitor
can use.  For <tt>SequenceExpression</tt> these are
<tt>expression1</tt> and <tt>expression2</tt>; for
<tt>AlternationExpression</tt> these are <tt>alternative1</tt>
and <tt>alternative2</tt>; for
<tt>RepeatExpression</tt> it is <tt>repetition</tt>; and for
<tt>LiteralExpression</tt> these are <tt>components</tt>.</p>
<p>The ConcreteVisitor class is <tt>REMatchingVisitor</tt>.  It
is responsible for the traversal because its traversal algorithm
is irregular.  The biggest irregularity is that a
<tt>RepeatExpression</tt> will repeatedly traverse its component.
The class <tt>REMatchingVisitor</tt> has an instance variable
<tt>inputState</tt>.   Its methods are essentially the same as
the <tt>match:</tt> methods of the expression classes in the
Interpreter pattern except they
replace the argument named <tt>inputState</tt> with the
expression node being matched.  However, they
still return the set of streams that the expression would match
to identify the current state.</p>
<pre>
visitSequence: sequenceExp
    inputState := sequenceExp expression1 accept: self.
    ^ sequenceExp expression2 accept: self.

visitRepeat: repeatExp
    | finalState |
    finalState := inputState copy.
    [inputState isEmpty]
        whileFalse:
            [inputState := repeatExp repetition accept: self.
            finalState addAll: inputState].
    ^ finalState

visitAlternation: alternateExp
    | finalState originalState |
    originalState := inputState.
    finalState := alternateExp alternative1 accept: self.
    inputState := originalState.
    finalState addAll: (alternateExp alternative2 accept: self).
    ^ finalState

visitLiteral: literalExp
    | finalState tStream |
    finalState := Set new.
    inputState
        do:
            [:stream | tStream := stream copy.
                (tStream nextAvailable:
                    literalExp components size
                ) = literalExp components
                    ifTrue: [finalState add: tStream]
            ].
    ^ finalState
</pre><a name="knownuses"><a>
<h3> Known Uses</h3><p>The Smalltalk-80 compiler has a Visitor class called ProgramNodeEnumerator.
It's used primarily for algorithms that analyze source code.
It isn't used for code generation or pretty-printing, although it could be.</p>
<p>IRIS Inventor [Str93]
is a toolkit for developing 3-D graphics applications. Inventor
represents a three-dimensional scene as a hierarchy of nodes, each
representing either a geometric object or an attribute of one.
Operations like rendering a scene or mapping an input event require
traversing this hierarchy in different ways. Inventor does this
using visitors called "actions." There are different visitors for
rendering, event handling, searching, filing, and determining
bounding boxes.</p>
<p>To make adding new nodes easier, Inventor implements a
double-dispatch scheme for C++. The scheme relies on run-time type
information and a two-dimensional table in which rows represent
visitors and columns represent node classes.  The cells store a
pointer to the function bound to the visitor and node class.</p>

<p>Mark Linton coined the term "Visitor" in the X Consortium's
Fresco Application Toolkit specification [LP93].</p>
<h3> Related Patterns</h3><p>Composite :
Visitors can be used to apply an operation over an object structure
defined by the Composite pattern.</p>
<p>Interpreter :
Visitor may be applied to do the interpretation.</p>
<hr>
<p><sup>10</sup>We could use function overloading to give these operations
the same simple name, like <tt>Visit</tt>, since the operations are
already differentiated by the parameter they're passed.  There are
pros and cons to such overloading.  On the one hand, it reinforces the
fact that each operation involves the same analysis, albeit on a
different argument.  On the other hand, that might make what's going
on at the call site less obvious to someone reading the code.  It
really boils down to whether you believe function overloading is good
or not.
</p>
<p><sup>11</sup>If we can have <em>double</em>-dispatch, then why not
<em>triple</em> or <em>quadruple</em>, or any other number?  Actually,
double-dispatch is just a special case of <strong>multiple
dispatch</strong>, in which the operation is chosen based on any number of
types.  (CLOS actually supports multiple dispatch.)  Languages that
support double- or multiple dispatch lessen the need for the
Visitor pattern.
</p><p>&nbsp;</p></body></html>

