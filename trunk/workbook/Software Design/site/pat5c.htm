<html><head>	<title>Interpreter</title><link href="ff.css" rel="stylesheet" type="text/css"></head><body>
<h2>Interpreter</h2>
<h3> Intent</h3><p>Given a language, define a represention for its grammar along with an
interpreter that uses the representation to interpret sentences in the
language.</p>
<h3> Motivation</h3><p>If a particular kind of problem occurs often enough, then it might be
worthwhile to express instances of the problem as sentences in a
simple language.  Then you can build an interpreter that solves the
problem by interpreting these sentences.</p>

<p>For example, searching for strings that match a pattern is a common
problem.  Regular expressions are a standard language for specifying
patterns of strings.  Rather than building custom algorithms to match
each pattern against strings, search algorithms could interpret a
regular expression that specifies a set of strings to match.</p>
<p>The Interpreter pattern describes how to define a grammar for simple
languages, represent sentences in the language, and interpret these
sentences.  In this example, the pattern describes how to define a
grammar for regular expressions, represent a particular regular
expression, and how to interpret that regular expression.</p>
<p>Suppose the following grammar defines the regular expressions:</p>
<pre>
expression ::= literal | alternation | sequence | repetition |
               '(' expression ')'
alternation ::= expression  '|' expression
sequence ::= expression '&amp;' expression
repetition ::= expression '*'
literal ::= 'a' | 'b' | 'c' | ... { 'a' | 'b' | 'c' | ... }*
</pre>
<p>The symbol <tt>expression</tt> is the start symbol, and <tt>literal</tt>
is a terminal symbol defining simple words.</p>
<p>The Interpreter pattern uses a class to represent each grammar rule.
Symbols on the right-hand side of the rule are instance variables of
these classes.  The grammar above is represented by five classes: an
abstract class RegularExpression and its four subclasses
LiteralExpression, AlternationExpression, SequenceExpression, and
RepetitionExpression.  The last three classes define variables that
hold subexpressions.</p>

<p align=CENTER><img src="Pictures/inter043.gif"></p>
<p>Every regular expression defined by this grammar is represented by an
abstract syntax tree made up of instances of these classes. For
example, the abstract syntax tree</p>
<p align=CENTER><img src="Pictures/inter042.gif"></p>
<p>represents the regular expression</p>
<pre>
raining &amp; (dogs | cats) *
</pre>
<p>We can create an interpreter for these regular expressions by defining
the Interpret operation on each subclass of RegularExpression.
Interpret takes as an argument the context in which to interpret the
expression.  The context contains the input string and information on
how much of it has been matched so far.  Each subclass of
RegularExpression implements Interpret to match the next part of the
input string based on the current context.  For example,</p><ul>
<li>LiteralExpression will check if the input matches the literal it
defines,</li>

<li>AlternationExpression will check if the input matches any of its
alternatives,</li>

<li>RepetitionExpression will check if the input has multiple copies of
expression it repeats,</li></ul>
<p>and so on.</p>
<h3> Applicability</h3><p>Use the Interpreter pattern when there is a language to interpret, and
you can represent statements in the language as abstract syntax trees.
The Interpreter pattern works best when</p><ul>
<li>the grammar is simple. For complex grammars, the class hierarchy for
the grammar becomes large and unmanageable.  Tools such as parser
generators are a better alternative in such cases.  They can interpret
expressions without building abstract syntax trees, which can save
space and possibly time.</li>

<li>efficiency is not a critical concern.  The most efficient interpreters
are usually <em>not</em> implemented by interpreting parse trees directly
but by first translating them into another form.  For example, regular
expressions are often transformed into state machines.  But even then,
the <em>translator</em> can be implemented by the Interpreter pattern, so
the pattern is still applicable.</li></ul>
<h3> Structure</h3> <p align=CENTER><img src="Pictures/inter041.gif"></p>
<h3> Participants</h3><ul>
<li><b>AbstractExpression</b> (RegularExpression)</li>


<ul>
<li>declares an abstract Interpret operation that is common to
all nodes in the abstract syntax tree.</li></ul>




<li><b>TerminalExpression</b> (LiteralExpression)</li>


<ul>
<li>implements an Interpret operation associated with terminal
symbols in the grammar.</li>
<p><!-- extra space --></p>
<li>an instance is required for every terminal symbol in a
sentence.</li></ul>



<li><b>NonterminalExpression</b> (AlternationExpression,
RepetitionExpression, SequenceExpressions)</li>


<ul>
<li>one such class is required for every rule <i>R</i> ::=
<i>R</i><sub>1</sub> <i>R</i><sub>2</sub> ... <i>R</i><sub>n</sub></I>
in the grammar.</li>
<p><!-- extra space --></p>
<li>maintains instance variables of type AbstractExpression
for each of the symbols <i>R</i><sub>1</sub> through
<i>R</i><sub>n</sub>.</li>
<p><!-- extra space --></p>
<li>implements an Interpret operation for
nonterminal symbols in the grammar. Interpret typically calls itself
recursively on the variables representing <i>R</i><sub>1</sub> through
<i>R</i><sub>n</sub>.</li></ul>



<li><b>Context</b></li>


<ul>
<li>contains information that's global to the interpreter.</li></ul>



<li><b>Client</b></li>


<ul>
<li>builds (or is given) an abstract syntax tree representing a
particular sentence in the language that the grammar defines.  The
abstract syntax tree is assembled from instances of the
NonterminalExpression and TerminalExpression classes.</li>
<p><!-- extra space --></p>
<li>invokes the Interpret operation.</li></ul></ul>
<h3> Collaborations</h3><ul>
<li>The client builds (or is given) the sentence as an abstract syntax
tree of NonterminalExpression and TerminalExpression instances.  Then
the client initializes the context and invokes the Interpret
operation.</li>

<li>Each NonterminalExpression node defines Interpret in terms of
Interpret on each subexpression.  The Interpret operation of each
TerminalExpression defines the base case in the recursion.</li>

<li>The Interpret operations at each node use the context to
store and access the state of the interpreter.</li></ul>
<h3> Consequences</h3><p>The Interpreter pattern has the following benefits and liabilities:</p><ol>
<li><em>It's easy to change and extend the grammar.</em>
Because the pattern uses classes to represent grammar rules, you can
use inheritance to change or extend the grammar.  Existing expressions
can be modified incrementally, and new expressions can be defined as
variations on old ones.</li>



<li><em>Implementing the grammar is easy, too.</em>
Classes defining nodes in the abstract syntax tree have similar
implementations.  These classes are easy to write, and often their
generation can be automated with a compiler or parser generator.</li>



<li><em>Complex grammars are hard to maintain.</em>
The Interpreter pattern defines at least one class for every rule
in the grammar (grammar rules defined using BNF may require multiple
classes).  Hence grammars containing many rules can be hard to
manage and maintain.  Other design patterns can be applied to
mitigate the problem (see Implementation).
But when the grammar is very complex, other techniques such as
parser or compiler generators are more appropriate.</li>



<li><em>Adding new ways to interpret expressions.</em>
The Interpreter pattern makes it easier to evaluate an expression in a
new way.  For example, you can support pretty printing or
type-checking an expression by defining a new operation on the
expression classes.  If you keep creating new ways of interpreting an
expression, then consider using the Visitor 
pattern to avoid changing the grammar classes.</li></ol>
<h3> Implementation</h3><p>The Interpreter and Composite 
patterns share many implementation issues. The following issues
are specific to Interpreter:</p><ol>
<li><em>Creating the abstract syntax tree.</em>
The Interpreter pattern doesn't explain how to <em>create</em> an
abstract syntax tree.  In other words, it doesn't address parsing.
The abstract syntax tree can be created by a table-driven parser, by a
hand-crafted (usually recursive descent) parser, or directly by the
client.</li>



<li><em>Defining the Interpret operation.</em>
You don't have to define the Interpret operation in the expression
classes.  If it's common to create a new interpreter, then it's better
to use the Visitor  pattern to put Interpret in a
separate "visitor" object.  For example, a grammar for a programming
language will have many operations on abstract syntax trees, such as
as type-checking, optimization, code generation, and so on. It will be
more likely to use a visitor to avoid defining these operations on
every grammar class.</li>




<li><em>Sharing terminal symbols with the Flyweight pattern.</em>
Grammars whose sentences contain many occurrences of a terminal symbol
might benefit from sharing a single copy of that symbol.  Grammars for
computer programs are good examples&#151;each program variable will
appear in many places throughout the code. In the Motivation example,
a sentence can have the terminal symbol <tt>dog</tt> (modeled by the
LiteralExpression class) appearing many times.
<p>Terminal nodes generally don't store information about their position
in the abstract syntax tree.  Parent nodes pass them whatever context
they need during interpretation.  Hence there is a distinction between
shared (intrinsic) state and passed-in (extrinsic) state, and the
Flyweight (195) pattern applies.</p>
<p>For example, each instance of LiteralExpression for <tt>dog</tt>
receives a context containing the substring matched so far.  And every
such LiteralExpression does the same thing in its Interpret
operation&#151;it checks whether the next part of the input contains a
<tt>dog</tt>&#151;no matter where the instance appears in the tree.</p></li></ol><a name="samplecode"><a>
<h3> Sample Code</h3><p>Here are two examples.  The first is a complete example in Smalltalk
for checking whether a sequence matches a regular expression.  The
second is a C++ program for evaluating Boolean expressions.</p>
<p>The regular expression matcher tests whether a string is in the
language defined by the regular expression. The regular expression is
defined by the following grammar:</p>
<pre>
expression ::= literal | alternation | sequence | repetition |
               '(' expression ')'
alternation ::= expression  '|' expression
sequence ::= expression '&amp;' expression
repetition ::= expression 'repeat'
literal ::= 'a' | 'b' | 'c' | ... { 'a' | 'b' | 'c' | ... }*
</pre>
<p>This grammar is a slight modification of the Motivation example.  We
changed the concrete syntax of regular expressions a little, because
symbol "<tt>*</tt>" can't be a postfix operation in Smalltalk.  So
we use <tt>repeat</tt> instead.  For example, the regular expression</p>
<pre>
(('dog ' | 'cat ') repeat &amp; 'weather')
</pre>
<p>matches the input string "<tt>dog dog cat weather</tt>".</p>
<p>To implement the matcher, we define the five classes described on
.  The class
<tt>SequenceExpression</tt> has instance variables
<tt>expression1</tt> and <tt>expression2</tt> for its children
in the abstract syntax tree.  <tt>AlternationExpression</tt>
stores its alternatives in the instance variables
<tt>alternative1</tt> and <tt>alternative2</tt>, while
<tt>RepetitionExpression</tt> holds the expression it repeats in its
<tt>repetition</tt> instance variable.
LiteralExpression has a <tt>components</tt> instance variable that
holds a list of objects (probably characters).  These represent the literal
string that must match the input sequence.</p>
<p>The <tt>match:</tt> operation implements an interpreter for the
regular expression.  Each of the classes defining the abstract syntax
tree implements this operation.  It takes
<tt>inputState</tt> as an argument representing the current state
of the matching process, having read part of the input string.</p>
<p>This current state is characterized by a set of input streams
representing the set of inputs that the regular expression could have
accepted so far.  (This is roughly equivalent to recording all states
that the equivalent finite state automata would be in, having
recognized the input stream to this point).</p>
<p>The current state is most important to the <tt>repeat</tt> operation.
For example, if the regular expression were</p>
<pre>
'a' repeat
</pre>
<p>then the interpreter could match "<tt>a</tt>", "<tt>aa</tt>",
"<tt>aaa</tt>", and so on.  If it were</p>
<pre>
'a' repeat &amp; 'bc'
</pre>
<p>then it could match "<tt>abc</tt>", "<tt>aabc</tt>",
"<tt>aaabc</tt>", and so on.  But if the regular expression were</p>
<pre>
'a' repeat &amp; 'abc'
</pre>
<p>then matching the input "<tt>aabc</tt>" against the subexpression
"<tt>'a' repeat</tt>" would yield two input streams, one having matched
one character of the input, and the other having matched two
characters.  Only the stream that has accepted one character will
match the remaining "<tt>abc</tt>".</p>
<p>Now we consider the definitions of <tt>match:</tt> for each class
defining the regular expression. The definition for
<tt>SequenceExpression</tt> matches each of its subexpressions in
sequence.  Usually it will eliminate input streams from its
<tt>inputState</tt>.</p>
<pre>
match: inputState
    ^ expression2 match: (expression1 match: inputState).
</pre>
<p>An <tt>AlternationExpression</tt> will return a state that consists
of the union of states from either alternative.  The definition of
<tt>match:</tt> for <tt>AlternationExpression</tt> is</p>
<pre>
match: inputState
    | finalState |
    finalState := alternative1 match: inputState.
    finalState addAll: (alternative2 match: inputState).
    ^ finalState
</pre>
<p>The <tt>match:</tt> operation for <tt>RepetitionExpression</tt>
tries to find as many states that could match as possible:</p>
<pre>
match: inputState
    | aState finalState |
    aState := inputState.
    finalState := inputState copy.
    [aState isEmpty]
        whileFalse:
            [aState := repetition match: aState.
            finalState addAll: aState].
        ^ finalState
</pre>
<p>Its output state usually contains more states than its input state,
because a <tt>RepetitionExpression</tt> can match one, two, or many
occurrences of <tt>repetition</tt> on the input state. The output
states represent all these possibilities, allowing subsequent elements
of the regular expression to decide which state is the correct one.</p>
<p>Finally, the definition of <tt>match:</tt> for
<tt>LiteralExpression</tt> tries to match its components against each
possible input stream.  It keeps only those input streams that have a
match:</p>
<pre>
match: inputState
    | finalState tStream |
    finalState := Set new.
    inputState
        do:
            [:stream | tStream := stream copy.
                (tStream nextAvailable:
                     components size
                ) = components
                    ifTrue: [finalState add: tStream]
            ].
        ^ finalState
</pre>
<p>The <tt>nextAvailable:</tt> message advances the input stream.  This
is the only <tt>match:</tt> operation that advances the stream.
Notice how the state that's returned contains a copy of the input
stream, thereby ensuring that matching a literal never changes the
input stream.  This is important because each alternative of an
<tt>AlternationExpression</tt> should see identical copies of
the input stream.</p>
<p>Now that we've defined the classes that make up an abstract syntax
tree, we can describe how to build it.
Rather than write a parser for regular expressions, we'll define
some operations on the <tt>RegularExpression</tt> classes so that
evaluating a Smalltalk expression will produce an abstract syntax tree
for the corresponding regular expression.  That lets us use the
built-in Smalltalk compiler as if it were a parser for regular
expressions.</p>
<p>To build the abstract syntax tree, we'll need to define
"<tt>|</tt>", "<tt>repeat</tt>", and "<tt>&amp;</tt>" as
operations on <tt>RegularExpression</tt>. These operations are
defined in class <tt>RegularExpression</tt> like this:</p>
<pre>
&amp; aNode
    ^ SequenceExpression new
        expression1: self expression2: aNode asRExp

repeat
    ^ RepetitionExpression new repetition: self

| aNode
    ^ AlternationExpression new
    alternative1: self alternative2: aNode asRExp

asRExp 
    ^ self
</pre>
<p>The <tt>asRExp</tt> operation will convert literals into
<tt>RegularExpressions</tt>.   These operations are defined in class
<tt>String</tt>:</p>
<pre>
&amp; aNode
    ^ SequenceExpression new
        expression1: self asRExp expression2: aNode asRExp

repeat
    ^ RepetitionExpression new repetition: self

| aNode
    ^ AlternationExpression new
        alternative1: self asRExp alternative2: aNode asRExp

asRExp
    ^ LiteralExpression new components: self
</pre>
<p>If we defined these operations higher up in the class hierarchy
(<tt>SequenceableCollection</tt> in Smalltalk-80,
<tt>IndexedCollection</tt> in Smalltalk/V), then they would
also be defined for classes such as <tt>Array</tt> and
<tt>OrderedCollection</tt>.  This would let
regular expressions match sequences of any kind of object.</p>
<p>The second example is a system for manipulating and evaluating
Boolean expressions implemented in C++.  The terminal symbols in this
language are Boolean variables, that is, the constants
<tt>true</tt> and <tt>false</tt>.   Nonterminal symbols represent
expressions containing the operators <tt>and</tt>, <tt>or</tt>, and
<tt>not</tt>.  The grammar is defined as
follows<sup>1</sup>:</p>
<pre>
BooleanExp ::= VariableExp | Constant | OrExp | AndExp | NotExp |
               '(' BooleanExp ')'
AndExp ::= BooleanExp  'and' BooleanExp
OrExp ::= BooleanExp  'or' BooleanExp
NotExp ::= 'not' BooleanExp
Constant ::= 'true' |  'false'
VariableExp ::= 'A' | 'B' | ... | 'X' | 'Y' | 'Z'
</pre>
<p>We define two operations on Boolean expressions. The first,
<tt>Evaluate</tt>, evaluates a Boolean expression in a context
that assigns a true or false value to each variable.  The second
operation, <tt>Replace</tt>, produces a new Boolean expression by
replacing a variable with an expression. <tt>Replace</tt> shows
how the Interpreter pattern can be used for more than just evaluating
expressions. In this case, it manipulates the expression itself.</p>
<p>We give details of just the <tt>BooleanExp</tt>,
<tt>VariableExp</tt>, and <tt>AndExp</tt> classes here. Classes
<tt>OrExp</tt> and <tt>NotExp</tt> are similar to <tt>AndExp</tt>.
The <tt>Constant</tt> class represents the Boolean constants.</p>
<p><tt>BooleanExp</tt> defines the interface for all classes that define
a Boolean expression:</p>
<pre>
class BooleanExp {
public:
    BooleanExp();
    virtual ~BooleanExp();

    virtual bool Evaluate(Context&amp;) = 0;
    virtual BooleanExp* Replace(const char*, BooleanExp&amp;) = 0;
    virtual BooleanExp* Copy() const = 0;
};
</pre>
<p>The class <tt>Context</tt> defines a mapping from variables to
Boolean values, which we represent with the C++ constants
<tt>true</tt> and <tt>false</tt>. <tt>Context</tt> has the
following interface:</p>
<pre>
class Context {
public:
    bool Lookup(const char*) const;
    void Assign(VariableExp*, bool);
};
</pre>
<p>A <tt>VariableExp</tt> represents a named variable:</p>
<pre>
class VariableExp : public BooleanExp {
public:
    VariableExp(const char*);
    virtual ~VariableExp();

    virtual bool Evaluate(Context&amp;);
    virtual BooleanExp* Replace(const char*, BooleanExp&amp;);
    virtual BooleanExp* Copy() const;
private:
    char* _name;
};
</pre>
<p>The constructor takes the variable's name as an argument:</p>
<pre>
VariableExp::VariableExp (const char* name) {
    _name = strdup(name);
}
</pre>
<p>Evaluating a variable returns its value in the current context.</p>
<pre>
bool VariableExp::Evaluate (Context&amp; aContext) {
    return aContext.Lookup(_name);
}
</pre>
<p>Copying a variable returns a new <tt>VariableExp</tt>:</p>
<pre>
BooleanExp* VariableExp::Copy () const {
    return new VariableExp(_name);
}
</pre>
<p>To replace a variable with an expression, we check to see if the
variable has the same name as the one it is passed as an argument:</p>
<pre>
BooleanExp* VariableExp::Replace (
    const char* name, BooleanExp&amp; exp
) {
    if (strcmp(name, _name) == 0) {
        return exp.Copy();
    } else {
        return new VariableExp(_name);
   }
}
</pre>
<p>An <tt>AndExp</tt> represents an expression made by ANDing two
Boolean expressions together.</p>
<pre>
class AndExp : public BooleanExp {
public:
    AndExp(BooleanExp*, BooleanExp*);
    virtual ~ AndExp();

    virtual bool Evaluate(Context&amp;);
    virtual BooleanExp* Replace(const char*, BooleanExp&amp;);
    virtual BooleanExp* Copy() const;
private:
    BooleanExp* _operand1;
    BooleanExp* _operand2;
};

AndExp::AndExp (BooleanExp* op1, BooleanExp* op2) {
    _operand1 = op1;
    _operand2 = op2;
}
</pre>
<p>Evaluating an <tt>AndExp</tt> evaluates its operands and returns
the logical "and" of the results.</p>
<pre>
bool AndExp::Evaluate (Context&amp; aContext) {
    return
        _operand1->Evaluate(aContext) &amp;&amp;
        _operand2->Evaluate(aContext);
}
</pre>
<p>An <tt>AndExp</tt> implements <tt>Copy</tt> and <tt>Replace</tt> by
making recursive calls on its operands:</p>
<pre>
BooleanExp* AndExp::Copy () const {
    return
        new AndExp(_operand1->Copy(), _operand2->Copy());
}

BooleanExp* AndExp::Replace (const char* name, BooleanExp&amp; exp) {
    return
        new AndExp(
            _operand1->Replace(name, exp),
            _operand2->Replace(name, exp)
        );
}
</pre>
<p>Now we can define the Boolean expression</p>
<pre>
(true and x) or (y and (not x))
</pre>
<p>and evaluate it for a given assignment of <tt>true</tt> or
<tt>false</tt> to the variables <tt>x</tt> and <tt>y</tt>:</p>
<pre>
BooleanExp* expression;
Context context;

VariableExp* x = new VariableExp("X");
VariableExp* y = new VariableExp("Y");

expression = new OrExp(
    new AndExp(new Constant(true), x),
    new AndExp(y, new NotExp(x))
);

context.Assign(x, false);
context.Assign(y, true);

bool result = expression->Evaluate(context);
</pre>
<p>The expression evaluates to <tt>true</tt> for this assignment to
<tt>x</tt> and <tt>y</tt>.  We can evaluate the expression with a
different assignment to the variables simply by changing the
context.</p>
<p>Finally, we can replace the variable <tt>y</tt> with a new expression and
then reevaluate it:</p>
<pre>
VariableExp* z = new VariableExp("Z");
NotExp not_z(z);

BooleanExp* replacement = expression->Replace("Y", not_z);

context.Assign(z, true);

result = replacement->Evaluate(context);
</pre>
<p>This example illustrates an important point about the Interpreter
pattern: many kinds of operations can "interpret" a sentence.  Of
the three operations defined for <tt>BooleanExp</tt>,
<tt>Evaluate</tt> fits our idea of what an interpreter should do most
closely&#151;that is, it interprets a program or expression and returns a
simple result.</p>
<p>However, <tt>Replace</tt> can be viewed as an interpreter as well.
It's an interpreter whose context is the name of the variable being
replaced along with the expression that replaces it, and whose result
is a new expression.  Even <tt>Copy</tt> can be thought of as an
interpreter with an empty context.  It may seem a little strange to
consider <tt>Replace</tt> and <tt>Copy</tt> to be interpreters, because
these are just basic operations on trees.  The examples in
Visitor  illustrate how all three operations can be
refactored into a separate "interpreter" visitor, thus showing that
the similarity is deep.</p>
<p>The Interpreter pattern is more than just an operation distributed
over a class hierarchy that uses the Composite 
pattern.  We consider <tt>Evaluate</tt> an interpreter because we
think of the <tt>BooleanExp</tt> class hierarchy as representing a
language.  Given a similar class hierarchy for representing automotive
part assemblies, it's unlikely we'd consider operations like
<tt>Weight</tt> and <tt>Copy</tt> as interpreters even though they
are distributed over a class hierarchy that uses the Composite
pattern&#151;we just don't think of automotive parts as a language.  It's
a matter of perspective; if we started publishing grammars of
automotive parts, then we could consider operations on those parts to
be ways of interpreting the language.</p><a name="knownuses"><a>
<h3> Known Uses</h3> 

<p>The Interpreter pattern is widely used in compilers implemented with
object-oriented languages, as the Smalltalk compilers are.  SPECTalk
uses the pattern to interpret descriptions of input file
formats [Sza92].  The QOCA constraint-solving toolkit
uses it to evaluate constraints [HHMV92].</p>
<p>Considered in its most general form (i.e., an operation distributed
over a class hierarchy based on the Composite pattern), nearly every
use of the Composite pattern will also contain the Interpreter
pattern.  But the Interpreter pattern should be reserved for those
cases in which you want to think of the class hierarchy as defining a
language.</p>
<h3> Related Patterns</h3><p>Composite :
The abstract syntax tree is an instance of the Composite pattern.</p>
<p>Flyweight 
shows how to share terminal symbols within the abstract syntax
tree.</p>
<p>Iterator :
The interpreter can use an Iterator to traverse the structure.</p>
<p>Visitor  can
be used to maintain the behavior in each node in the abstract syntax
tree in one class.</p>
<hr>
<p><sup>1</sup>For simplicity, we ignore operator precedence and
assume it's the responsibility of whichever object constructs the
syntax tree.
</p><p>&nbsp;</p></body></html>

